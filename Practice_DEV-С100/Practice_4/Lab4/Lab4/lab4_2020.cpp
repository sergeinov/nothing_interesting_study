/*************************************************************
	Практическое занятие №4. Встроенные массивы.
							Простейшие алгоритмы сортировки и поиска.
							
*************************************************************/

#include <cstdlib>
#include <ctime>
#include <iostream>

#define	  stop __asm nop

int main()
//Задания, помеченные * не являются обязательными. Но выполнение их крайне желательно!!!
{
	setlocale(LC_ALL, "Russian");
	///////////////////////////////////////////////////////////////
	//			Указатели (продолжение)                              
	///////////////////////////////////////////////////////////////

	//Задание 1. Модификатор const. 
	//В каждом из заданий объявите указатель требуемого вида. 
	//Посредством каждого указателя попробуйте:
	//1) получить значение по адресу
	//2) записать новое значение по адресу
	//3) модифицировать указатель
	//Замечания:
	//1.операторы явного преобразования типа использовать не следует
	//2.если компилятор не позволяет выполнить операцию, то комментируйте эту строку с пояснением
	{
		int value = 5;

		//Задание 1a. Указатель является константой. 

		int* const pvalue = &value;		// инициализация обязательна
		*pvalue = 6;					// ok
		// pvalue++;					// ошибка - указатель константный
		int* tempp = pvalue;			// ok
		*tempp = 4;						//  ok 4
		stop


			//Задание 1б. Указываемое значение является константой.

			const int* pvalue1;		// инициализация необязательна
		pvalue1 = &value;
		//*pvalue1 = 6;			// ошибка - значение является константой
		pvalue1++;				// ok
		//int* tempp1 = pvalue1;	// компилятор не позволить обычному указателю присвоить указаетль с константным значением
		stop

			// *******************************************************


			//Задание 1в. И указатель, и указываемое значение
			//являются константами.

			const int* const pvalue2 = &value;	// инициализация обязательна
		int temp2 = *pvalue2;				// 5
		// *pvalue2 = 6;					// ошибка - значение является константой
		// pvalue2++;						// ошибка - значение является константой
		//int* tempp2 = pvalue2;			// компилятор не позволить обычному указателю присвоить константное значение

		stop

			// *******************************************************


			//Задание 1г. Указатель на переменную, объявленную с
			//ключевым словом const. 
			const int nN = 1;

		//Объявите указатель и проинициализируйте его выражением - &nN	

		const int* pnN = &nN;
		// int* pnN = &nN;						// компилятор не позволить обычному указателю присвоить константное значение

		// даже отведет память под такую перемнную
		stop

	}
	// *******************************************************

	//Задание 2. Явное преобразование указателя. 
	//Иногда возникает необходимость одни и те же данные интерпретировать по-разному,

	//например, целое можно представить как совокупность четырех
			//байтов и работать с каждым байтом по отдельности. Для этого
			//нужно иметь возможность "указывать" как на целое, так и на байт. 

			//Следовательно, возникает необходимость явного преобразования указателя. 

			//Подсказка: для правильной интерпретации этого задания воспользуйтесь
			//возможностями отладчика представлять данные в интересующем
			//Вас виде (в данном случае - в шестнадцатеричном) - для
			//этого используйте правую клавишу мыши,находясь в окне

			//переменных и изменяйте пункт - Hexadecimal display !!!!!!!!!!!!!!!!!

	{
		unsigned int nObject5 = 0x55667788;			// 1432778632 
		unsigned int* pnObject5 = &nObject5;			// 0x008ff6e0 адрес на  0x55667788

		//Раскомментировав следующую строчку кода, обратите внимание на сообщение компилятора 
		//- он не считает преобразование "легальным" (безопасным)

		unsigned char* pucObject5;

		// pucObject5=static_cast<unsigned char*>(pnObject5);	// считает небезопасным преобразование, возможны серьезные потери данных переменной

		pucObject5 = reinterpret_cast<unsigned char*>(pnObject5);	//а такое
					//преобразование - целиком на совести программиста.
					//Его можно применять, только четко представляя себе
					//результат преобразования (2)

		//Откомментируйте (!) следующие строчки следующим образом:
		// сс=..., 	pucObject5 - изменился? 	*pucObject5=...

		char cc = *(pucObject5++);	// 0x88 // инкрементируем char на 1 байт и получаем младший байт
		cc = (*pucObject5)++;		// 0x77	 получаем второй младший байт

		cc = ++ * (pucObject5);		// получаем значение, увеличивая 0x77 на 1  = 0x79	// изменился nObject5=0x55667988
		cc = *(++pucObject5);		// 0x66 получаем 3-й байт
		stop
	}
		///////////////////////////////////////////////////////////////
		//			Встроенные массивы                               
		///////////////////////////////////////////////////////////////

	//Задание 3. 
	//Имеется одномерный встроенный массив, проинициализированный при объявлении 
	//Отсортируйте массив по возрастанию значений. 
	//Используйте "пузырьковую" сортировку  
	// Правильность решения проверьте с помощью отладчика

	{
		std::cout << "\nЗадание 3..." << std::endl;
		int ar[] = { 5, 4, 7,  8, 1, 2, 6, 0, 10, 12, 77, 11,
					  6, 8, 33, 21, 1, 2, 3, 4};
		int sizeAr = sizeof(ar) / sizeof(int);  // размер массива

		// вариант без лишней сортировки
		for (int i = 0; i < sizeAr; i++)
		{
			bool flag = false;		// для выключения лишнего перебора чисел (была ли хотя бы одна перестановка)

			// поиск из оставшихся неупорядоченных чисел
			for (int j = 0; j < sizeAr - 1; j++)
			{
				if (ar[j + 1] < ar[j])
				{
					// обмен местами значения текущего и минимального элементов
					int temp = ar[j + 1];
					ar[j + 1] = ar[j];
					ar[j] = temp;

					flag = true;
				}
			}

			if (!flag)
			{
				break;
			}

			// вывод массива
			std::cout << i + 1 << " цикл: \t";
			for (auto& i : ar)
			{
				std::cout << i << ",";
			}
				std::cout << std::endl;
		}

		stop
	}


	// *******************************************************
	//Задание 4  
	//в)Инициализация массива строковыми литералами:
	//Объявите массив указателей и проинициализируйте его строковыми литералами . 
	//Выведите  массив на печать.
	{
		std::cout << "\nЗадание 4..." << std::endl;
		const char* pArrStr[] = { "TEST", "TEST2" };		// отводит в статической памяти место для строки. Выделяет память под 2 указателя

		for (int i = 0; i < sizeof(pArrStr) / sizeof(pArrStr[0]); i++)
		{
			std::cout << pArrStr[i] << std::endl;
		}
	}


// *******************************************************
	//Задание 5. 
	//a) Объявите одномерный неинициализированный массив ( размером N)
	//Задайте значения элементов с помощью генератора случайных чисел.
		
	//Подсказка 1: для генерации случайных чисел используйте функцию
	//стандартной библиотеки - rand() (<cstdlib>)
	// int tmp= rand(); // получим случайное значение в диапазоне от 0 до RAND_MAX
    	//значение RAND_MAX задано в файле <stdlib.h>  и равно  0x7fff(32767)
	
	//если Вам требуется задать иные границы диапазона при генерации случайного числа, 
	//то это можно сделать так:
	//v1 = rand() % 100;         // v1 в диапазоне 0 - 99
	//v2 = rand() % 100 + 1;     // v2 в диапазоне 1 - 100
	//v3 = rand() % 30 + 1985;   // v3 в диапазоне 1985-2014 
	
	//Подсказка 2: На самом деле те значения, которые создаются генератором случайных
	//чисел являются «псевдослучайными», то есть при двух последовательных запусках
	//приложения Вы получаете две одинаковые последовательности значений.
	//Для того чтобы генерируемые "случайные" значения были разными при каждом 
	//запуске приложения используйте функции стандартной библиотеки srand() (<cstdlib>)
	//и time() (<ctime>).
	//Функция srand() осуществляет «привязку» начала генерации к указанному в качестве параметра значению.
	//Функция time() задает эту точку отсчета, считывая текущее время
	//srand( time( 0 ) );
//(Подсказки в файле Алгоритмы для лабораторной работы_3. pdf)


	//б) Выведите массив на печать

	//в)Отсортируйте массив по убыванию значений. 
	//Используйте сортировку "выбором"
	{
		
		srand(time(NULL));
		int arrRandom[10];
		int sizeArr2 = sizeof(arrRandom) / sizeof(arrRandom[0]);  // размер массива

		std::cout << "\nЗадание 5..." << std::endl;
		// заполнение массива случайными числами
		for (int i = 0; i < sizeArr2; i++)
		{
			//  рандомные числа от 1 -100
			arrRandom[i] = rand() % 100 + 1;
			std::cout << arrRandom[i] << " ";
		}

		// проходим по всему массиву
		for (int i = 0; i < sizeArr2 - 1; i++)
		{
			// здесь индекс с наибольшего элемента
			int indexMax = i;

			// поиск наибольшего из оставшихся неупорядоченных чисел
			for (int j = i + 1; j < sizeArr2; j++)
			{
				if (arrRandom[j] > arrRandom[indexMax])
				{
					indexMax = j;
				}
			}
			// обмен местами значения текущего и наибольшего элементов
			int temp = arrRandom[indexMax];
			arrRandom[indexMax] = arrRandom[i];
			arrRandom[i] = temp;

			// вывод массива
			std::cout << i + 1 << " цикл: \t";
			for (int i = 0; i < sizeArr2; i++)
			{
				std::cout << arrRandom[i] << " ";
			}
			std::cout  << std::endl;
		}

		stop
	}
	
		// 

// *******************************************************

		//Задание 7. 
		//Объявите встроенный одномерный массив, состоящий из N элементов целого типа. 
		//Напишите фрагмент кода, который вводит целые числа с помощью
		//потока ввода в объявленный Вами массив, каждый раз ( на каждой итерации!)
		//упорядочивая полученное значение по возрастанию.
		//Для проверки выводите массив на консоль на каждой итерации`
	{
		std::cout << "\nЗадание 7..." << std::endl;
		int arrNN[10] = { 0 };
		int number;
		int sizeArr3 = sizeof(arrNN) / sizeof(int);  // размер массива
		int count = 0;                              // для вывода количества циклов

		// через пузырьковую сортировку, упорядочивая полученное значение по возрастанию
		// идем циклом с конца массива
		for (int i = sizeArr3 - 1; i >= 0; i--)
		{
			std::cout << "Введите значение: " << std::endl;
			std::cin >> number;
			arrNN[i] = number;      // присваиваем принятое на вход число массиву по индексу (в данном случае последнему)

			// поиск наименьшего из оставшихся неупорядоченных чисел
			for (int j = 0; j < sizeArr3 - 1; j++)
			{
				if (arrNN[j + 1] < arrNN[j])
				{
					// обмен местами значения текущего и минимального элементов
					int temp = arrNN[j + 1];
					arrNN[j + 1] = arrNN[j];
					arrNN[j] = temp;
				}
			}

			// вывод массива
			count++;
			std::cout << count << " цикл: \t";
			for (int i = 0; i < sizeArr3; i++)
			{
				std::cout << arrNN[i] << " ";
			}
			std::cout << std::endl;
		}

		stop
	}
		

// *******************************************************
	//Задание 8. 

	//Простой поиск.
	//Модифицируйте предыдущее задание следующим образом:
	//очередное введенное значение помещается в массив только при условии, 
	//что там еще такого нет (то есть дубли игнорируются)
	{
		std::cout << "\nЗадание 8..." << std::endl;
		int arrNN2[10] = { 0 };
		int number;
		int sizeArr4 = sizeof(arrNN2) / sizeof(int);  // размер массива
		int count = 0;                              // для вывода количества циклов

		// через сортировку выбором, упорядочивая полученное значение по возрастанию
		// идем циклом с конца массива
		for (int i = sizeArr4 - 1; i >= 0; i--)
		{
			std::cout << "Введите значение: " << std::endl;
			std::cin >> number;

			// проверка на дубликат числа в массиве			// ?
			for (int k = sizeArr4 - 1; k >= 0; k--) {
				if (arrNN2[k] == number) {
					std::cout << "Есть в массиве!" << std::endl;
					std::cin >> number;
				}
			}

			arrNN2[i] = number; // присваиваем принятое на вход число массиву по индексу (в данном случае последнему)  

			// поиск из оставшихся неупорядоченных чисел
			for (int j = 0; j < sizeArr4 - 1; j++)
			{

				if (arrNN2[j + 1] < arrNN2[j])
				{
					// обмен местами значения текущего и минимального элементов
					int temp = arrNN2[j + 1];
					arrNN2[j + 1] = arrNN2[j];
					arrNN2[j] = temp;
				}
			}

			// вывод массива
			count++;
			std::cout << count << " цикл: \t";
			for (int i = 0; i < sizeArr4; i++)
			{
				std::cout << arrNN2[i] << " ";
			}
			std::cout << std::endl;
		}
	}

// *******************************************************
	//Задание 9
	//Объявите одномерный встроенный массив элементов типа char.
	//Сформируйте значения элементов массива с помощью генератора случайных 
	//чисел таким образом, чтобы в массиве были только символы '*' и '_'  
	
	//"сдвиньте звездочки" в начало массива, например:
	//было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
	//стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
	//и распечатайте массив 
//(Подсказки в файле Алгоритмы для лабораторной работы_4. pdf)
	{
		std::cout << "\nЗадание 9..." << std::endl;
		srand(time(NULL));
		char arrRandom2[10];
		int sizeArr2 = sizeof(arrRandom2) / sizeof(arrRandom2[0]);  // размер массива

		// заполнение массива случайными числами и замена их на символы  '*'  '_'
		for (int i = 0; i < sizeArr2; i++)
		{
			//  рандомные числа от 1 -100
			arrRandom2[i] = rand() % 2;
			// замена на символы
			if (arrRandom2[i] == 0) {
				arrRandom2[i] = '*';
			}
			else {
				arrRandom2[i] = '_';
			}
			std::cout << arrRandom2[i] << " ";
		}

		// проходим по всему массиву пузырьковой сортировкой (в порядке возрастания)
		for (int i = 0; i < sizeArr2 - 1; i++)
		{
			bool flag = false;		// для выключения лишнего перебора чисел (была ли хотя бы одна перестановка)

			// сравниваем элементы и меняем местами
			for (int j = 0; j < sizeArr2 - i - 1; j++)
			{
				if (arrRandom2[j] == '_')
				{
					// обмен местами элементов
					int temp = arrRandom2[j];
					arrRandom2[j] = arrRandom2[j + 1];
					arrRandom2[j + 1] = temp;

					flag = true;
				}
			}

			if (!flag) {
				break;
			}

			// вывод массива
			std::cout << "\n" << i + 1 << " цикл: \t";
			for (int i = 0; i < sizeArr2; i++)
			{
				std::cout << arrRandom2[i] << " ";
			}
		}
	}
// *******************************************************
	//Задание 10
	//объявите одномерный встроенный массив  из N элементов и проинициализируйте его.
	//а) сдвиньте все элементы массива вправо на 1 позицию
	//б) (Циклическая перестановка). Сдвиньте все элементы массива вправо на 1 позицию , 
	//но последний элемент не должен быть утерян. Его следут переместить в начало.
	//например,  { 5, 2, 11, 4, 23, 9 } ->  {9, 5, 2, 11, 4, 23 }

	//в)(Кольцевой буфер) выведите массив на печать, циклически сдвинув элементы вправо на 1 позицию.
	//При решении задачи не следует перемещать элементы массива, а надо использовать кольцевой буфер.
	// Одномерный массив можно "свернуть" в кольцо и считать, что за последним элементом следует начальный и
	// потом установить "новое" начало массива.

	{
		std::cout << "\nЗадание 10..." << std::endl;
		// кольцевой буфер (без перестановки)
		int arrCircle[] = { 4, 5, 6, 7, 8, 9, 10 };
		int sizeArr5 = sizeof(arrCircle) / sizeof(arrCircle[0]);  // размер массива  // 7

		int last = sizeArr5 - 1;

		for (int i = 0; i < sizeArr5; i++)
		{
			// используем вывод по индексу
			std::cout << arrCircle[(last++) % sizeArr5] << " ";  // 6, 0 , 1, 2, 3, 4, 5
		}
	}

	/*		Циклическая перестановка
	{
		int arrCircle[] = { 4, 5, 6, 7, 8, 9, 10 };
		int sizeArr = sizeof(arrCircle) / sizeof(arrCircle[0]);  // размер массива  // 7

		int temp = arrCircle[sizeArr - 1];		// сохраняем последний элемент

		// кольцевая перестановки в право
		for (int i = sizeArr - 2; i >= 0; i--)
		{
			// сдвигаем вправо на 1 позицию
			arrCircle[i + 1] = arrCircle[i];
		}
		arrCircle[0] = temp;		// ставим элемент вперед

		// вывод массива
		for (int i = 0; i < sizeArr; i++)
		{
			std::cout << arrCircle[i] << " ";
		}
	}
	*/

// *******************************************************
	//Задание 11 (*)
	//алгоритм "тасования колоды"
	//объявите одномерный встроенный массив  из N элементов и 
	// заполните  его неповторяющимися числами из заданного отрезка 
	//натурального ряда, расположенными в случайном порядке
//(Подсказки в файле Алгоритмы для лабораторной работы_3.pdf)
//Алгоритм:
//Массив  A [N] инициализируется последовательными значениями из отрезка, например [0,N-1]
//index=N-1, где index- максимальное значение индекса.

//В цикле по index выполняется перемешивание значений:
//	1. Генерируется случайное число  R из отрезка [0, index]
//	2. Выполняется обмен значений A[index]  и  A[R]
//	3. index=index -1
//	4. Если index==0, то конец
//	5. Переход к шагу 1    
	{
		std::cout << "\nЗадание 11..." << std::endl;
		srand(time(NULL));

		int arrDeck[] = { 10, 20, 30, 40, 50, 60, 70, 80, 90, 100};
		int sizeArr6 = sizeof(arrDeck) / sizeof(arrDeck[0]);	// размер массива   10

		int index = sizeArr6 - 1;								// 9
		int randomIndex;
		int temp;

		// условие: Когда индекс 0 - завершается цикл
		while (index != 0) {
			// генерируем случайное число от 0 до 10
			randomIndex = rand() % (index + 1);

			// выполняем обмен значений
			temp = arrDeck[randomIndex];

			arrDeck[randomIndex] = arrDeck[index];

			arrDeck[index] = temp;

			// уменьшаем индекс массива
			index = index - 1;
		}

		// вывод массива
		for (int i = 0; i < sizeArr6; i++)
		{
			std::cout << arrDeck[i] << " ";
		}
	
	}
	
	
// *******************************************************

}