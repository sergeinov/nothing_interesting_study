
/*************************************************************
	Практическое занятие №5. Функции.
	Объявление, определение, вызов.
	Передача параметров. Возвращение значения.
	
*************************************************************/
#include <iostream>
#include <tchar.h>
//#include <cstdio>
//#include <cstdarg>
#include "other.h"


#define	  stop __asm nop

int _tmain()
{
	setlocale(LC_ALL, "Russian");
	/////////////////////////////////////////////////////////////////////////////
	// Задание 1. Ссылки.
	// 1.1. Объявите ссылку на тип double. Посредством ссылки измените значение
	double value = 2.5;
	double& refVal = value;
	refVal = 3.5;


	// 1.2. Раскомментируйте  следующую строчку. 
	//Что следует сделать, чтобы linker не выдавал ошибки при создании exe-файла?
	// Подсказка: ref - это внешняя по отношению к данному файлу ссылка!
	//Подумайте, где надо объявить эту внешнюю ссылку, а где ее определить.
	

	ref++;		// 11 

	// 1.3. Раскомментируйте следующую строку. 
	//Что следует сделать, чтобы компилятор не выдавал ошибки 
	//int& ref1 = 1;

	const int& ref1 = 1;			// создает адрес, выделяет память на sizeof(int)

	// 1.4. Задан указатель:
	char c='A';
	char* pc = &c;

	//Объявите ссылку на указатель. Посредством ссылки измените
	//а) значение по адресу
	//б) сам адрес

	char*& refPc = pc;
	*refPc = 'B';
	refPc++;



	 // 1.5. Объявите и определите функцию, вычисляющую квадрат числа, переданного в качестве параметра.
	 //  параметр должен быть ссылкой. Вызовите функцию с заданными ниже аргументами
	//Замечание (!!!):
	// объявления функций принято помещать в заголовочный файл (.h),
	// а определения функций- в файл реализации (.cpp)
	// в задании заготовлены файлы other.cpp и other.h. 
	//Эти файлы можно использовать для размещения  Ваших функций.
	 {
		//std::cout << "\nЗадание 1.5" << std::endl;
		int x = 10;
		int res1 = square(x);	 // 100		// преобразует const& int в обычный & int
		int res2 = square(5);    // 5		// 5 это константное значение по ссылке
		stop
	}


////////////////////////////////////////////////////////////////////////////	
	
	//Задание 2. Отличия при передаче параметров 
	//а) по значению, б) по ссылке, в) по указателю

	// 2.1. Объявите и определите три функции, которые увеличивают заданное
	//с помощью параметра значение на 1 
	// а) - IncByValue(),
	// б) - IncByPointer(), 
	//в) - IncByReference() . 
	//Проверьте правильность с помощью отладчика.
	//
	 {
		// std::cout << "\nЗадание 2.1" << std::endl;
		 int val = 1;//значение этой переменной должно быть увеличено с помощью
					 //каждой из функций на единицу
		 
		 val = IncByValue(val);	     // val = 1
		 IncByReference(val);		// val = 2
		 IncByPointer(&val);		   // val = 3
		
		 stop
	 }
		
	// 2.2 Передача параметров c помощью указателя и по ссылке.
	//Создайте функцию (функции) Swap(), которая меняет значения
	//переменных nX и nY местами.
	
	// а)Функция должна принимать два указателя на int  и оперируя этими указателями
	//   должна менять значения переменных в вызывающей (!) программе

	// б)Функция должна принимать две ссылки на int и оперируя этими ссылками
	//   должна менять значения переменных в вызывающей (!) программе
	//Проверьте правильность с помощью приведенного ниже фрагмента.
	 {
		 //std::cout << "\nЗадание 2.2" << std::endl;
		 int nX = 1;
		 int nY = -1;
		 Swap(&nX, &nY);  //поменяли местами значения nX и nY с помощью указателей на nX и nY
		 Swap(nX, nY);    //а теперь обратно с помощью ссылок на nX и nY
		 stop
	 }
		////////////////////////////////////////////////////////////////////////////

		//Задание 3. Массивы в качестве аргументов.
		// 3.1. Напишите функцию печати элементов во встроенном одномерном массиве

		//Например:
		//int ar[N] = {список инициализаторов};//подумайте - как и где должны быть заданы N
		//PrintArray(ar, ... может быть, понадобится передать еще какие-нибудь данные);
	 {
		 std::cout << "\nЗадание 3" << std::endl;
		 const int N = 6;		// размер массива
		 int ar[N] = { 10, 20 ,30 ,40, 50 };
		 PrintArray(ar, N);
		 stop
	 }
		// 3.2. Напишите функцию поиска минимального элемента во встроенном одномерном массиве

		//Например:
		//int ar[N] = {список инициализаторов};//подумайте - как и где должны быть заданы N и M
		//int res = Min(ar, ... может быть, понадобится передать еще какие-нибудь данные);
	 {
		// std::cout << "\nЗадание 3.2" << std::endl;
		 int ar[] = { 10, 4, 22, 5, 6 };
		 size_t size2 = sizeof(ar) / sizeof(ar[0]);
		 int res = Min(ar, size2);
		 stop
	 }
	
		// 3.3. Напишите функцию сравнения двух строк - MyStrCmp():
		//Функция должна принимать два указателя на сравниваемые строки 
		//(возможно Вы должны указать компилятору, что функция не имеет права модифицировать 
		//содержимое строк)

		//Функция должна возвращать отрицательное значение, если
		//первая строка лексикографически меньше второй, 0 - если
		//они равны и положительное значение, если первая строка
		//больше второй.
		//Замечание: при лексикографическом способе сравниваются коды символов (!!!), а не длина строк
		// если код  символа первой строки > соответствующего кода символа второй строки, 
		// то первая строка > второй 
		//Вспомните, что признаком конца строки является нулевой байт.

		//Создайте две строки для сравнения:
		//Вызовите функцию сравнения
		//Выведите результат сравнения с помощью cout:
	 {
		 std::cout << "\nЗадание 3.3" << std::endl;

		 char arr1[] = "HELLO";
		 char arr2[] = "HELLo";
		 int result = 0;
		 std::cout << MyStrCmp(arr1, arr2);

		 stop
	 }
////////////////////////////////////////////////////////////////////////////
	//Задание 4. Фукнции работы со строками

		// 4.1. Создайте и вызовите функцию, которая принимает в качестве параметра 
		//порядковый номер - nN - месяца, 
		//а возвращает  указатель на символьную строку, содержащую название заданного месяца. 
		//Подсказка: 
		//-для того, чтобы данная функция работала корректно, очень важно – как объявлена строка,
		//указатель на которую требуется вернуть.
		//Кроме того, было бы неплохо предусмотреть защиту при некорректном значении месяца.
		{
		 std::cout << "\nЗадание 4.1" << std::endl;

			 const char* mStr = NameOfMonth(7);
			std::cout << mStr << std::endl;
			stop
		}

		// 4.2. Создайте и вызовите функцию, которая по указанным целочисленным параметрам
		// (день, месяц, год)
		//формирует соответствующую строку 
		//например, 12, 11, 2020 => "12.11.2020" 
		//  или  1, 1, 2020 => "1.1.2020"   (а можно "01.01.2020")

		// Подсказки – 
		// 1) для перевода целого числа в строковое представление можно использовать функцию 
		// стандартной библиотеки _itoa(), 
		// заголовочный файл <cstdlib>– смотри MSDN).
		// char* _itoa( int value, char * buffer,  int radix );

		// 2) для формирования результирующей строки Вам скорее всего потребуются функции стандартной 		
		// библиотеки strcpy() и strcat
		//заголовочный файл <cstring>– смотри MSDN).
		// char * strcpy( char * dest, const char * source); 
		// - копирует  Си строку source, включая завершающий нулевой символ, в строку dest
		// char * strcat( char * dest, const char * source);  
		//- Объединение строк. Копия строки source  добавляется в конец строки dest. 
		// Нулевой символ конца строки dest заменяется первым символом строки source
		// в конец dest добавляется символ конца строки ('\0').

		// 3) !!! скорее всего, при использовании этих функций, Вы получите сообщение компилятора:
		//Severity	Code	Description	Project	File	Line	Suppression State
		//Error	C4996	strcpy': This function or variable may be unsafe.Consider using strcpy_s 				//instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS.
		//Для того, чтобы это сообщение не выдавалось, перед всеми #include добавьте 
		//  #define _CRT_SECURE_NO_WARNINGS
	

		//В задании привести объявление, определение и вызов функции.
		{
			std::cout << "\nЗадание 4.2" << std::endl;

			std::cout << DataStr(22,9,2020) << std::endl;
			stop
		}

		//  <cstdlib> для _itoa() подключен уже в глубинах <iostream>

////////////////////////////////////////////////////////////////////////////
	//Задание 5. Возвращение адреса.
	//Напишите функцию, которая находит адрес минимального элемента в массиве,
	// таким образом, чтобы ее вызов можно было использовать слева от знака 
	// равенства: *MyMin(параметры) = 0;
		{
			//std::cout << "\nЗадание 5" << std::endl;
			int arrMM[] = { 33, 4, 6, 10, 12, 2 };
			int size_MM = sizeof(arrMM) / sizeof(arrMM[0]);

			int* pMin = addr_min(arrMM, size_MM);

			// можно вызвать слева от знака 
			*addr_min(arrMM, size_MM) += 1;			// 3  (2 + 1)

			//std::cout << (*addr_min(arrMM, size_MM) += 1) << std::endl;
		}
////////////////////////////////////////////////////////////////////////////
	//Задание 6 (*).
	//Дан одномерный массив из N элементов
	//Известно: значения элементов могут быть только в диапазоне 0, 1, 2 …., 30, 31.  
	//Напишите две функции :
	//•первая - «выясняет» какие значения встречаются в массиве четное число раз, 
	//а какие – нечетное(при этом для результата можно использовать только один int) = >
	//int   f1(параметры);
	//•вторая –  выводит результат(Например: 0 встречается в массиве четное число раз)

	//В задании привести объявление, определение и вызов функций.
		{
			std::cout << "\nЗадание 6" << std::endl;
			int arrNumber[31];
			int sizeArr = sizeof(arrNumber) / sizeof(arrNumber[0]);  // размер массива

			// заполнение массива случайными числами
			for (int i = 0; i < sizeArr; i++)
			{
				//  рандомные числа от 1 - 31
				arrNumber[i] = (rand() % 31 + 1);
			}

			int searchNumber = 1;

			// сколько число встречается раз в массиве
			searchEvenAndOddnumber(arrNumber, sizeArr, searchNumber);
		}
		
	return 0;
}//main
