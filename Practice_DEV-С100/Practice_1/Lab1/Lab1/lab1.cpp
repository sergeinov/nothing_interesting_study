//лабораторная работа №1 по курсу Dev-C100
/*
	В результате выполнения данной работы слушатель получает много мелких но необходимых
	для дальнейшей работы навыков, поэтому задание построено как последовательность 
	закомментированных блоков, которые требуется последовательно раскомментировать, 
	отвечая  при этом на поставленные вопросы.

	Примерная последовательность действий при отладке проекта:
	1. наберите (исправьте, раскомментируйте нужный фрагмент) исходный текст программы;
	2. откомпилируйте (Build/Compile  ***.cpp или Ctrl+F7)
		Замечание: этот этап явно вызывать необязательно, но полезно для начинающего 6
			программиста, т.к. позволяет увидеть ошибки (errors) и предупреждения
			(warnings), возникающие при компиляции данного конкретного файла;
	3. скомпонуйте проект(Build/Build ***.exe или F7)
		Замечание 1: этот этап тоже необязателен, но настоятельно рекомендуем, т.к. 
			позволяет перекомпилировать только измененные файлы и в случае отсутствия
			ошибок всегда полезно посмотреть на выдаваемые компилятором замечания;
		Замечание 2: перед тем, как строить проект, неплохо убедиться  в том, что 
			исполняемый код будет содержать информацию для отладчика - 
				(Build/Configuration Manager.../Configuration - Debug - тип сборки проекта);
	4. поставьте на интересующих Вас строках исходного кода точки останова (breakpoints) - F9 или 
		просто кликните левой кнопкой на левой серой полосе окна редактирования; 
	5. запустите программу в режиме отладки 
		(Debug/Start... или  F5);
	6."Перемещаться" по коду во время отладки можно по шагам (от строки к строке). Для этого можно использовать клавишу F10.
	7. Кроме того, можно переходить от одной "точки останова" к другой посредством F5.
	8. ВАЖНО!!! Когда программа останавливается на некоторой "точке останова", то код инструкций, находящихся на соответствующей строке
       еще не выполнен! Для того, чтобы он выполнился, требуется сделать "шаг", т.е. нажать клавишу F10 или кнопку Step Over. 	   

  Замечание: для перечисленных выше действий приведены комбинации клавиш и соответствующие 
		пункты меню, однако во многих случаях гораздо быстрее то же самое можно сделать с 
		помощью кнопок на Tool Bar, в чем слушатель может преуспеть самостоятельно.

*/

#include  <climits>
#include <cfloat>



int nTwin=1;			//глобальная переменная
extern int nTest;		//?		10 - внешняя переменная  с test.cpp

#define	  stop __asm nop	//с помощью макроподстановки задаем "пустую" команду.
							//Эта макроподстановка нужна только для того, чтобы
							//можно было поставить на этой строке точку останова.

int main()
{
 //**********************************************************
	//Задание 1. Работа с отладчиком. Базовые типы данных. Выполняя программу по шагам, 
	//следите за значениями переменных и интерпретируйте результат (помните, что 
	//количество байт, отводимых под int, системо-зависимо).
	//Обратите внимание на разную интерпретацию отладчиком signed и unsigned целых типов 
	//данных, а также на внутреннее представление отрицательных целых чисел.

	//Рядом с каждой строкой кода напишите комментарий, в котором укажите значение
	//переменной ПОСЛЕ выполнения соооветствующей инструкции
	//Помните, что если Вы поставили точку останова на какой-то строке, то отладчик
	//остановится ДО выполнения инструкции
	//чтобы продвигаться по коду пошагово, можно использовать клавишу F10 или кнопку Step Over

	//Для того, чтобы во ВРЕМЯ ОТЛАДКИ наблюдать за значениями переменных, можно использовать окошки "Autos", "Locals", "Watch"
	// окошко "Watch" удобно тем, что тем можно вводить не только имена наблюдаемых переменных, 
	//но и выражения, которые Вы хотели бы вычислить
	// Для того, чтобы увидеть 16-ричное представление значения, надо в контекстном меню  одного из окошек "Autos", "Locals", "Watch"
	// выбрать флажок Hexadecimal Display, для того, чтобы вернуться к 10-чному представлению - снять флажок Hexadecimal Display

	//Подсказка: очень удобно для просмотра значений  не самим набирать текст, а копировать его из окна просмотра
	
	
	char cByte = 'A'; //65  'A'  ,		cByte	0x41 'A'	char

	cByte    = 0x42; //66 'B'  		cByte	0x42 'B'	char

	cByte    = 66;  //66 'B'		cByte 0x42 'B'		char

	cByte    = -1;  // 0xff 'я'						char
	
	unsigned char ucByte = 0x41;  // 'A' 65 
	ucByte   = 'B';				  // 'B'  66   / 0x42 
	ucByte   =	-1;				  //  'я' 255 / 0xff 

	int iInt =  0xffffffff;		  // -1

	unsigned int uiInt = 0xffffffff; //  4294967295

	float fFloat = 1.f;				 // 1.00000000

	double dDouble = 1.;			 // 1.0000000000000000

	// Выполните фрагмент, приведенный далее. В комментариях отразите,
	// что реально заносится в переменную. Объясните разницу между этим 
	// значением и инициализатором.
	

	double d = 0.1234567890123456789123456789; //  0.12345678901234568
	float  f = d;							   // 0.123456791   -   точность float 6 символов // Warning преобразование "double" в "float", возможна потеря данных


	
	d	=	1.;								      // 1.0000000000000000
	d	=	0.999999999999999999999999999999999;  // 1.0000000000000000

	stop
	
	// В комментариях напишите результат, возвращаемый оператором sizeof для
	// переменной типа wchar_t (ее размер)
	wchar_t cw = L'Ф';	   //   1060 'Ф'  /  0x0424 'Ф'  // 2 байта    Unicode
	size_t n = sizeof(cw); //  2 байта 

	stop


// **************************************************************
	//Задание 2a. Неявное приведение типов данных.
	//Объясните разницу результата при выполнении (1) и (2):
	//Покажите явно (напишите в коде) преобразования, которые неявно выполняет компилятор

	iInt=1;
	double dDouble1=static_cast<double>(iInt/3);		// сначала деление, потом присваивание // 0.00000000000000000

	double dDouble2= static_cast<double>(iInt)/3.;	//? (2)  0.33333333333333331


	// Ассоциативность операторов.
	// Синтаксис языка C допускает "цепочечное" присваивание
	// (как в строках (1) и (2)). Посмотрев результаты выполнения строк (1) и (2)
	// (значения переменных dDouble, fFloat, nInt, sShort, cByte), определите порядок 
	// выполения присваиваний при цепочечной записи и объясните результат.
	// Расставте скобки, явно определяющие порядок выполнения, как это сделал бы компилятор.
	// Объясните (в комментариях) предупреждения (warnings) компилятора.
	//
	short sShort;
	dDouble=(fFloat=(iInt=(sShort=(cByte=(3.3/3)))));	// (1) cByte =1 > sShort =1 > iInt=1 > fFloat=1.00000000 > dDouble=1.0000000000000000
	
	cByte=(sShort=(iInt=(fFloat=(dDouble=(3.3/3)))));	// (2) dDouble =1.0999999999999999  > fFloat=1.10000002 > iInt=1 > sShort=1 > cByte=1

	//ниже Вам дан пример "небрежного" использования неявного приведения типов, что может 
	// привести к нежелательным результатам - объясните (в комментариях), к каким?
	// Напишите явно преобразования, которые неявно выполняет компилятор
	//Используйте оператор приведения типа static_cast

	iInt	=	257;						//Hexadecimal Display: ???   0x00000101
	cByte	=   static_cast<char>(iInt);	//Hexadecimal Display:  char cByte = 1   /  0x01   / '\x1'- эскейп-последовательность

	unsigned char cN1=255, cN2=2, cSum;
	cSum = static_cast<unsigned char>(static_cast<int>(cN1) + static_cast<int>(cN2));	// cSum = 1 	//cN1 = 0xff 255	/  cN2 = 0x02  2	прежде чем выполнять выражение, доводит регистр до размера int

	//Сравните предыдущую строчку с приведенной ниже. Объясните (в комментариях),
	//почему в следующей строке не происходит выход за разрядную сетку
	// Напишите явно преобразования, которые неявно выполняет компилятор
	int iSum = static_cast<int>(cN1) + static_cast<int>(cN2);		//  257

	//Напишите, почему при сложении одинаковых значений (одинаковых в двоичной системе) 
	// в строках (1) и (2) получаются разные результаты
	// Напишите явно преобразования, которые неявно выполняет компилятор и объясните,
	// что при этом происходит
	char c1=0xff, c2=2;  // c1 = -1   // c2 = 2  0x02
	unsigned char uc1=0xff, uc2=2;      // uc1  = 255  0xff  // uc2 =0x02  2
	int iSum1= static_cast<int>(c1) + static_cast<int>(c2);   //?(1)   1
	int iSum2= static_cast<int>(uc1) + static_cast<int>(uc2); //?(2)   257

	stop
	
// ***********************************************************
	//Задание 2b. Явное приведение типов данных.
	//Проинтерпретируйте результат (значения переменной dDouble) в строке (3)
	// Напишите явно преобразования, которые неявно выполняет компилятор
	int nTmp=100, nn=3;
	dDouble=3.3 + static_cast<double>(nTmp / nn); // (3) =?  dDouble= 36.299999999999997


	//Получите результат без потери точности с помощью оператора явного
	//приведения типа
	double dDouble3 = 3.3 + (static_cast<double>(nTmp) / static_cast<double>(nn));		// (4) 36.633333333333333


// *******************************************************
		// Задание 3. Область действия, область видимости и
			//				время существования переменных

			//   В этом фрагменте фигурируют три переменных с одним и тем же именем 
			// nTwin - одна глобальная (определена выше, в начале модуля) вторая - локальная внутри функции main(), 
			// третья - вложенная локальная внутри блока. 
			//   В данном задании требуется в выделенных местах фрагмента определить и откомментировать,
			// к какой из переменных идет обращение (к глобальной, к какой из локальных),
			//а также факт существования и видимости для всех переменных

			//	Для выполнения задания рекомендуется пользоваться окнами "Locals" и "Watches"
			// Подсказка: - в окно "Watches" можно поместить как nTwin так и ::nTwin

	// Задание 3.1.

		nTwin = 100; // глобальная "глюк" отладчика -  мусор //  ::nTwin = 100

		nTwin += 1;	//  глобальная "глюк" отладчика - мусор  //  ::nTwin  = 101
		// Обратите внимание на небольшой "глюк" отладчика. Хотя локальная переменная nTwin
		// до следующей строки еще не определена (и формально даже не существует), но место
		// под нее в стеке функции main уже выделено (и там мусор). Если теперь в  окно 
		// "Watches" поместить просто nTwin, то отладчик будет показывать значение этой, еще 
		// не объявленной локальной переменной (что-то вроде -858993460 или 0xcccccccc), 
		// хотя должен формально показывать значение глобальной переменной, объявленной ранее.
		// Компилятор при этом все вычисляет верно.
		// Если надо увидеть именно значение глобальной переменной, то надо явно указать в окне
		// "Watches" глобальную область видимости, т.е. написать там ::nTwin.
		// Примечание: вот еще один аргумент за то, чтобы не создавать конфликты имен.
		int nTwin;		//  локальная   
		nTwin = 200;	//  200 
		::nTwin = ::nTwin + 1;	// глобальная ::nTwin 102 
		{
			int nTwin;		//   новая локальная  
			nTwin = -1;		//  - 1
			::nTwin += 1;	//  ::nTwin = 103   
			nTwin += 1;		//  0  
			stop			// ставим стоп чтоб увидеть переменную выше - nTwin
		}

		nTwin -= 1;	// 199
	// Задание 3.2
	
		//В этом фрагменте фигурируют  также три переменных с одним и тем же именем
		// nTest - глобальная (определена в другом модуле) вторая - локальная внутри main,  третья - локальная внутри блока, 
		nTest = 1000;		//  глобальная extern - ::nTest = 1000
		int nTest = -2000;   // новая локальная переменная
		stop
		{
			int nTest = 200;  // новая локальная переменная
			nTest += 2;			// 202
			stop
		}
		nTest += 2;			// -1998

	

// *******************************************************
	// Задание 4. Спецификатор класса памяти - static
	// а) Для каждой итерации цикла напишите значения пременных nLocal# и nStatic#.
	// б) Напишите, когда выполняется инициализация переменных?
	// в) Поясните (в комментарии) разницу между способом инициализации 
	//     переменных nStatic1 и nStatic2 
	
	for (int i=0; i<3; i++)
	{
		static int nStatic1 = 100;    // сразу присвоение
		int nLocal1 = 100;
		int nLocal2 = 200;
		static int nStatic2 = (nLocal2+=1) * 2;   // сначала вычисление выражения, потом присвоение
		nStatic1+=1;
		nStatic2+=1;
		nLocal1+=1;
		stop
		//nLocal1=		101		101		101
		//nLocal2=		201		200		200
		//nStatic1=		101		102		103
		//nStatic2=		403		404		405
	}
	// Напишите:
	//   а) как изменилось поведение пременной nStatic1?
	//   б) как эта переменная ИНИЦИАЛИЗИРОВАНА ?
	for (int i=0; i<3; i++)
	{
		static int nStatic1;  //  0    // при определении статическим переменным присваивается  0
		nStatic1 = 100;			// новая инициализация   и определение при каждом цикле
		int nLocal1 = 100;		// новая инициализация   и определение при каждом цикле
		nStatic1+=1;
		nLocal1+=1;
		stop
		//nLocal1=		101		101		101
		//nStatic1=		101		101		101
	}



// *******************************************************
	// Задание 5. Перечисления - enum
	// Обратите внимание на явную и неявную инициализацию констант
	// Выполняя задание по шагам, следите за значениями, которые
	// принимает переменная myColors


	enum eColors
	{
		BLACK,
		BLUE,
		GREEN,
		RED=5,
		YELLOW,
		WHITE=RED+4
	};
	
	eColors   myColors;	//объявление переменной типа eColors 
	myColors=BLACK;		// 0
	myColors=BLUE;		// 1
	myColors=GREEN;		// 2
	myColors=RED;		// 5
	myColors=YELLOW;	// 6
	myColors=WHITE;		// 9

	int nnn = BLACK; //    0    //любой целочисленной переменной можно присвоить
							  //значение из списка инициализирующих значений

	//Именованные константы можно использовать в выражениях:
	nnn = BLUE + YELLOW;	//  6 + 1 = 7

	//Раскомментируйте следующую строку и обратите
	//внимание на  ошибку при компиляции 
	myColors = static_cast<eColors>(1);	 // BLUE = 1 // Чтобы компилятор не выдавал ошибки, требуется явное приведение типа

	// Выполните следующее присваивание НЕ меняя перечисление и тип переменной myColors?
	myColors = static_cast <eColors>(1 + 2 + 3);   // YELLOW = 6
	stop
	


// *******************************************************
	// Задание 6.1 Логический тип bool
	// Выполняя задание по шагам, следите за значениями
	// переменной b и интерпретируйте результат. Напишите эти значения в комментариях

	int nNumber = 1;
	bool b = (nNumber != 0); //  true
	b = (nNumber == 0);		//	false
	b = (nNumber > 0);		//	true
	b = (nNumber > 1);		//  false
	b = 5;					// true

	//Вы всегда можете преобразовать логическое значение к целому
	//явно или компилятор может это сделать самостоятельно (неявно)
	//Обратите внимание: как интерпретирует значения логических переменных компилятор?
	int tmp =  b + 1; //  2		b = 5, значит b = true / 1	  // true = 1;  false = 0



// *******************************************************
	// Задание 7. Модификатор const и переменные

	{
		//Раскомментируйте следующие две строчки и объясните (в комментариях)
		//ошибки при компиляции 

			//const int nN;		//  константа требует явную инициализацию переменной
			//nN = 1;			//  нельзя модифицировать константу
	}


	return 0;//код завершения приложения
}	// Конец функции main()

