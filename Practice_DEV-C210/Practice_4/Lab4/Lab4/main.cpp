// Контейнеры STL: 
//stack, queue, priority_queue
//set, multiset, map, multimap

//#include "stdafx.h"
#include <stack>
#include <queue>
#include <set>
#include <map>
#include <list>
#include <vector>
#include <string>
#include <clocale>
#include"template.h"
#include"Point.h"
#include"Case.h"

#include <iostream>

using namespace std;

#define stop __asm nop

// Point
std::ostream& operator<<(std::ostream& os, const Point& place)	// распечатать координаты
{
	os << "\nКоординаты:\n"
		<< "x = " << place.m_x
		<< "\n"
		<< "y = " << place.m_y;
	return os;
};

// Point перегрузка для  Point*
std::ostream& operator<<(std::ostream& os, const Point* place)
{
	os << "\nКоординаты:\n"
		<< "x = " << place->m_x
		<< "\n"
		<< "y = " << place->m_y;
	return os;
}

// функция условия для list  remove_if
bool NegPoint(const Point& object)
{
	return ( object.m_x < 0 && object.m_y < 0 );
}

int main()
{
	setlocale(LC_ALL, "Rus");
	
	//Напишите шаблон функции для вывода значений stack, queue, priority_queue
	//обратите внимание на то, что контейнеры предоставляют РАЗНЫЕ методы для 
	//получения значений
	

	// PrintAdapter();



	////////////////////////////////////////////////////////////////////////////////////
	//stack

	//Создайте стек таким образом, чтобы
	//а) элементы стека стали копиями элементов вектора
	//б) при выводе значений как вектора, так и стека порядок значений был одинаковым 
	vector<int> vInt = { 1, 2, 3, 4, 5 };
	stack<int, std::vector<int>> st(vector<int>(vInt.rbegin(), vInt.rend()));

	PrintAdapter(st);
	stop;


	////////////////////////////////////////////////////////////////////////////////////
	//queue

	//Создайте очередь, которая содержит указатели на объекты типа Point,
	//при этом явно задайте базовый контейнер.
	//Измените значения первого и последнего элементов посредством front() и back()
	//Подумайте, что требуется сделать при уничтожении такой очереди?
	
	queue<Point, deque<Point>> q1;
	q1.push(Point(5, 5));
	q1.push(Point(1, 1));
	q1.push(Point(8, 8));
	Point& fr = q1.front();
	Point& bk = q1.back();
	PrintAdapter(q1);
	
	fr = Point(2, 2);
	bk = Point(4, 4);
	PrintAdapter(q1);

	while ( !q1.empty() )
	{
		q1.pop();
	};

	PrintAdapter(q1);

	stop;

	////////////////////////////////////////////////////////////////////////////////////
	//priority_queue
	//а) создайте очередь с приоритетами, которая будет хранить адреса строковых литералов - const char*
	//б) проинициализируйте очередь при создании с помощью вспомогательного массива с элементами const char*
	//в) проверьте "упорядоченность" значений (с помощью pop() ) - если они оказываются не упорядоченными, подумайте:
	//		что сравнивается при вставке?
	const char* ar[] = { "Bool", "is", "also", "important" };
	priority_queue<const char*, std::vector<const char*>, Case> pr(ar, ar + 4);

	PrintAdapter(pr);		// не упорядочены	// для сравнения используются адреса  и сравнивается видом  "return x < y"
							// создали предикат Case, который сравнивает первые символы строки, таким образом сортируется
	
	stop;




	
	
	////////////////////////////////////////////////////////////////////////////////////
	//set
	//a) создайте множество с элементами типа Point - подумайте, что необходимо определить
	//		в классе Point (и каким образом)
	//б) распечатайте значения элементов с помощью шаблона, реализованного в предыдущей лаб. работе
	//в) попробуйте изменить любое значение...
	//г) Создайте два множества, которые будут содержать одинаковые значения
	//		типа int, но занесенные в разном порядке
	//д) Вставьте в любое множество диапазон элементов из любого другого
	//	контейнера, например, элементов массива	(что происходит, если в массиве имеются дубли?)

	set<Point> mySet = { Point(1,1),Point(3,3),Point(12,12),Point(6,6),Point(10,10) };

	PrintAll(mySet);
	stop;

	set<Point>::iterator it = mySet.begin();
	//*it = Point(22, 22);					// ! итератор предназначен только для чтения

	set<int> mySet2 = { 1,2,3,4,5 };			// 1, 2, 3, 4, 5
	mySet2.insert(2);							// 1, 2, 3, 4, 5		// дубли игнорируются
	PrintAll(mySet2);

	set<int> mySet3 = { 5,4,3,2,1 };			// 1, 2, 3, 4, 5		// упорядочивается
	PrintAll(mySet3);

	int arr5[] = { 1, 2, 3, 6, 7 };
	mySet3.insert(arr5, arr5 + 5);				// 1, 2, 3, 4, 5, 6, 7		// дубли игнорируются
	PrintAll(mySet3);						

	stop;


	////////////////////////////////////////////////////////////////////////////////////
	//map, multiset
	//а) создайте map, который хранит пары "фамилия, зарплата" - pair<const char*, int>,
	//	при этом строки задаются строковыми литералами
	//б) заполните контейнер значениями посредством operator[] и insert()
	//в) распечатайте содержимое

	pair<const char*, int> pr1("Иванова", 20000);

	map<const char*, int> mp;
	// 3 способа заполнения
	mp.insert(pr1);
	mp.insert(pair<const char*, int>("Сидоров", 15000));
	mp[ "Петров" ] = 40000;


	//г) замените один из КЛЮЧЕЙ на новый (была "Иванова", вышла замуж => стала "Петрова")

	stop
	

	
		
		//д) Сформируйте любым способом вектор с элементами типа string.
		//Создайте (и распечатайте для проверки) map<string, int>, который будет
		//содержать упорядоченные по алфавиту строки и
		//количество повторений каждой строки в векторе
	




		//е) 
		//задан массив:
		//const char* words[] = {"Abba", "Alfa", "Beta", "Beauty" ,...};
		//создайте map, в котором каждой букве будет соответствовать совокупность 
		//лексиграфически упорядоченных слов, начинающихся с этой буквы.
		//Подсказка: не стоит хранить дубли одной и той же строки
	
		//'A' -  "Abba" "Alfa"
		//'B' -  "Beauty" "Beta"  ...
		//...
		

		//ж)
		//создайте структуру данных, которая будет хранить информацию о студенческих группах.
		//Для каждой группы должны хранится фамилии студентов (по алфавиту). При этом 
		//фамилии могут дублироваться
		//Сами группы тоже должны быть упорядочены по номеру
		//
		//номера 




	////////////////////////////////////////////////////////////////////////////////////
	//multimap
	//а) создайте "англо-русский" словарь, где одному и тому же ключу будут соответствовать
	//		несколько русских значений - pair<string,string>, например: strange: чужой, странный...
	//б) Заполните словарь парами с помощью метода insert или проинициализируйте с помощью 
	//		вспомогательного массива пара (пары можно конструировать или создавать с помощью шаблона make_pair)
	//в) Выведите все содержимое словаря на экран
	//г) Выведите на экран только варианты "переводов" для заданного ключа. Подсказка: для нахождения диапазона
	//		итераторов можно использовать методы lower_bound() и upper_bound()




   

  stop

	return 0;
}

