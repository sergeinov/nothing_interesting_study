#include "myRect.h"
#include "myString.h"
#include "myBochka.h"
#include <iostream>

#define stop __asm nop

	// вариант с массивом
	//Rect BoundingRect(Rect r1, Rect r2)
	//{
	//	
	//	Rect temp((r1.Get()[0] + r2.Get()[0]), 
	//			 (r1.Get()[1] + r2.Get()[1]), 
	//			 (r1.Get()[2] + r2.Get()[2]), 
	//			 (r1.Get()[3] + r2.Get()[3]));

	//	return temp;	//	компилятор формируя значение с помощью конструктора копий копирует
	//					//	из стека в область зарезервированную вызывающей функцией
	//};

	Rect BoundingRect(Rect r1, Rect r2)
	{
		
		int x1, x2, y1, y2, xx1, xx2, yy1, yy2;
		r1.GetAll(&x1, &x2, &y1, &y2);			// вызов GetAll
		r2.GetAll(&xx1, &xx2, &yy1, &yy2);		// вызов GetAll
		int res1 = (x1 > xx1) ? x1 : xx1 ;		// если левая сторона первого прямоугольника больше 
												// левой стороны второго прямоугольника
		int res2 = (x2 > xx2) ? x2 : xx2;		// тут также только правая сторона
		int res3 = (y1 > yy1) ? y1 : yy1;					// и т.д.
		int res4 = (y2 > yy2) ? y2 : yy2;
		Rect temp(res1, res2, res3, res3);		// конструктор с параметрами

		return temp;							// конструктор копирования
		// деструктор r2
		// деструктор r1
	};

	// вариант с массивом
	Rect BoundingRect2(const Rect& r1, const Rect& r2) 
	{
		const int* p1 = r1.Get();
		const int* p2 = r2.Get();
		Rect temp((p1[0] + p2[0]),
				  (p1[1] + p2[1]),
				  (p1[2] + p2[2]),
				  (p1[3] + p2[3]));

		delete p1;
		delete p2;
		return temp;	//	компилятор формируя значение с помощью конструктора копий копирует
						//	из стека в область зарезервированную вызывающей функцией
	};

int main()
{
	setlocale(LC_ALL, "Rus");
	using namespace std;
	{
	//Задание 1.Объявление класса. Создание экземпляра класса.
	//Вызов методов класса. 
	//Откройте закладку Class View - (здесь Вы увидите имена методов и
	//данных - классов Rect и MyString)
	//Обратите внимание на пиктограммы слева от имен членов класса - они
	//обозначают спецификатор доступа к каждому члену класса.

	//Какой конструктор вызывается при создании экземпляра класса?
	
		Rect rect;		// вызов конструктора по умолчанию ( в текущем случае был пустой)
		stop			// ошибка, только в случае существующего коснтруктора с параметрами и отстутствия определенного конструктора без параметров
	

	//1a. Объявите и определите конструктор с параметрами для
	//инициализации переменных класса. Создайте экземляры класса Rect
	//с помощью конструктора с параметрами. Если компилятор выдает
	//ошибку в предыдущем фрагменте, подумайте - чего ему не
	//хватает? Добейтесь отсутствия ошибок.
	//Выполняя задание с самого начала по шагам, определите:
	//в какой момент происходит вызов конструктора(какого?)?

	//Замечание*: хорошо было бы учесть тот факт, что прямоугольник
	//может оказаться "ненормализованным", то есть m_left>m_right или/и
	//m_top>m_bottom
	//Подсказка: учтите, что пользователь Вашего класса может указывать
	//в качестве параметров любые значения! Например:

	//! Это параметры координат прямогульника в системе координат.
	// left - right - top - bottom
		Rect rrr(4,4,3,3);		// компилятор создаст экземпляр и вызовет конструктор с параметрами


		stop
	//1б. При конструировании объекта посредством конструктора без параметров
	//предусмотрите инициализацию переменных класса, например, нулем

		Rect rrr2;			// m_left = 0; m_right = 0; m_top = 0; m_bottom = 0


		stop
		//1в. Объявите, определите и вызовите метод класса InflateRect(), 
		//который увеличивает размеры прямоугольника на заданные приращения
		//(раздвигая стороны от центра - каждую сторону на свое значение).
		//Подсказка: объявить и определить методы можно не только "вручную",
		//но и с помощью Wizard-a Class View. Для этого: откройте закладку
		//ClassView окна проекта, сделайте активным класс Rect и нажмите
		//правую кнопку мыши - в появившемся контекстном меню выберите
		//Add/Add Member Function... С помощью появившейся диалоговой панели
		//"дайте указания" Wizard-у как объявить и определить метод.

		rrr.InflateRect(2, 1, 3, 4);


		stop
	}

	//Задание 2.Перегрузка конструкторов и методов класса.
	//Конструктор копирования.
	{
		//2а.Объявите и определите конструктор копирования в классе Rect.
		//Выполняя задание по шагам, определите, какой
		//конструктор вызывается при создании r1,r2,r3 и r4?
		//Чему равны переменные созданных объектов?
		Rect r1;					// вызов конструктора по умолчанию {m_left=0 m_right=0 m_top=0 ...}
		Rect r2(1, 2, 3, 4);		// вызов конструктора с параметрами {m_left=1 m_right=2 m_top=3 ...}
		Rect r3 = r1;				// Вызов конструктора копирования(нормальная форма)    {m_left=0 m_right=0 m_top=0 ...}
		Rect r4(r2);				// Вызов конструктора копирования(функциональныая форма вызова) {m_left=1 m_right=2 m_top=3 ...}
		stop


		//2б. Объявите и определите в классе Rect метод InflateRect(),
		//который принимает два аргумента, по умолчанию равных 1, и 
		//раздвигает стороны прямоугольника на на заданные приращения.
		//Для каких объектов вызывается функция InflateRect()?

		r1.InflateRect(1,1);			// вызван метод с двумя параметрами   r1 {m_left=1 m_right=1 m_top=1 ...}
		r2.InflateRect(2,2);			// вызван метод с двумя параметрами   r2  {m_left=3 m_right=4 m_top=5 ...}
		//Какая из функций InflateRect() вызывается в каждом из трех случаев?
		r3.InflateRect(2,2,2,2);		// вызван метод с четырмя параметрами  r3 {m_left=2 m_right=2 m_top=2 ...}
		r3.InflateRect(3,3);			// вызван метод с двумя параметрами    r3 {m_left=5 m_right=5 m_top=5 m_bottom=5}
		r3.InflateRect(5);				// вызван метод с двумя параметрами    r3 {m_left=10 m_right=10 m_top=6 m_bottom=6}
		r3.InflateRect();				// вызван метод с двумя параметрами    r3 {m_left=11 m_right=11 m_top=7 m_bottom=7}
		stop

	}
	
	//Задание 3.Спецификаторы доступа. Инкапсуляция. 
	{
		Rect r;
		//Раскомментируйте следующую строку. Объясните ошибку
		//компилятора

		//int tmp = r.m_left;			// нет доступа к приватному полю класса  // только создание в публичной области класса даст доступ к полю


		//Введите в класс Rect метод void SetAll(...),
		//который присваивают переменным класса передаваемые
		//значения. Вызовите созданный метод, проверьте корректность. 
		r.SetAll(4, 5, 3, 6);

		//Введите в класс Rect парный метод GetAll(...),
		//который "достает" значения private-переменных класса.
		//Вызовите созданный метод, проверьте корректность. 
	
		// вариант с массивом
		 int a = r.Get()[0];	// 4

		 // хороший вариант с параметрами
		 int x1, x2, y1, y2;						// создаем значения в которые будем возвращать приватные поля
		 r.GetAll(&x1, &x2, &y1, &y2);

		 stop
		// или возврат через статический массив или через аргументы функции  или  возврат одного поля
	}

	{
		//Задание 4.Передача экземпляра класса в качестве параметра
		//функции. Возвращение объекта класса по значению. Поставив
		//остановы в конструкторе копирования или выполняя фрагмент
		//по шагам, определите: в какой момент происходит обращение
		//к конструктору копирования. 
		//Создайте глобальную функцию 
		// Rect BoundingRect(Rect, Rect);
		//которая принимает два объекта класса Rect по значению и
		//возвращает объект класса Rect, который является прямоугольником,
		//в который вписаны заданные прямоугольники. Как происходит
		//передача параметров и возвращение объекта класса?
		{
			// передается анонимный неименованный обьект по значению
			//Rect r3 = BoundingRect(Rect(2, 2, 2, 2), Rect(5, 5, 3, 3));

			Rect r1(1, 2, 3, 4), r2(5, 6, 7, 8), r3;
			// 1. Конструктор с параметрами для r2  + Normalize()	
			// 2. Конструктор с параметрами для r1 + Normalize() 

			r3 = BoundingRect(r1, r2);				//  {m_left=6 m_right=8 m_top=10 m_bottom=12}
			// 1. Конструктор копирования для r2
			// 2. Конструктор копирования для r1
			// 3. Функция BoundingRect()
			// 4. Внутри функции - Метод Get()
			// 5. Констурктор с параметрами
			// 6. Функция копирования
			// 7. Возврат
			// 8. деструктор
			stop

			//	//Задание 4а. Передача объектов по ссылке.
			//	//Создайте глобальную функцию BoundingRect2, которая выполняет ту же
			//	//задачу, принимая параметры по ссылке
			//	//Вызываются ли конструкторы при передаче параметров?

			r3 = BoundingRect2(r1, r2);			// {m_left = 6 m_right = 8 m_top = 10 m_bottom=12}
			// 1. Функция
			// 2. Метод Get()
			// 3. Констурктор с параметрами
			// 4. Конструктор копирования
			// 5. Возврат
			stop
		}

		//Задание 4б.Реализуйте ту же задачу (BoundingRect) методом класса
		Rect r1(1, 2, 3, 4), r2(5, 6, 7, 8), r3;

		r3.BoundingRect(&r1, &r2);		// {m_left = 6 m_right = 8 m_top = 10 m_bottom=12}
		
		stop
	}

	//Задание 5. Когда вызываются конструкторы и деструкторы.
	//Объявите и определите
	//явный деструктор класса. Поставьте остановы в 
	//конструкторе (конструкторах) и деструкторе. Определите: когда для
	//каждого из объектов вызывается конструктор, а когда - деструктор?
	{
		Rect r1;							// создание обьекта с конструктором по умолчанию {m_left=0 m_right=0 m_top=0 ...}
		Rect*	pR = new Rect(1,2,1,2);		//  динамическое создание обьекта с параметрами (существует пока не уничтожить явно)
		{
			Rect r2(r1);		// вызов констуктора копирования {m_left=0 m_right=0 m_top=0 ...}
			Rect arRect[2];		// массив из двух объектов Rect (вызывается конструктор по умолчанию)
			for(int i=0; i<3; i++)
			{
				static Rect r3 (i,i,i,i);		// вызов конструктора с параметрами при первом выполнении, вызов деструктора в конце программы
				Rect r4(*pR);					// вызов конструктора копирования по указателю pR {m_left=1 m_right=2 m_top=1 ...}
				Rect r5(i,i,i,i);				// вызов конструктора с параметрами 
				
				// вызов деструктора для r4
				// вызов деструктора для r5
			}
		// вызов деструктора для r2
		// вызов деструктора для arRect
		}

		// удаление динамического объекта
		delete pR;		// вызов деструктора
		stop
		
		// вызов деструктора для r1
	}

 
	//Задание 6.Конструктор + деструктор = функциональное
	// замыкание. Класс MyString
	// Посредством конструктора (конструкторов) и деструктора обеспечьте
	//корректные инициализацию и деактивацию объекта
	//C помощью остановов определите когда происходит
	//захват и освобождение памяти для строки-члена класса
	{
		MyString s1;
		MyString s2 = s1;
		stop
	}

	{
		MyString	str1("It's my string1!");
		//Создайте метод GetString(), который обеспечит доступ к хранящейся строке.
		//С помощью cout и метода GetString() распечатайте строку объекта str1
		//Замечание: подумайте, как следует корректно реализовать метод GetString().


		//Подсказка 1:
		//приведенный ниже код должен работать:
		std::cout<<str1.GetString()<<std::endl;		// "It's my string1!"

		//Подсказка 2:
		//приведенный ниже код НЕ должен работать:
		//str1.GetString()[1] = 'W';				// нельзя менять данные в константном методе
													// нужно ставить const char* GetString()
		//Подсказка 3:
		//приведенный ниже код должен работать:
		const MyString	str2("It's my string2!");	// нужно ставить char* GetString() const
		std::cout<<str2.GetString()<<std::endl;		// "It's my string2!"  
	}
	stop

	{
		//6a. Раскомментируйте следующий фрагмент. Подумайте - какие
		//неприятности Вас ожидают. Попробуйте исправить положение (как?)
			{
				// в констукторе копирования выделяем отдеьную память для поля char* m_pStr
				MyString str1("The first string!");
				MyString str2 = str1;
			}
			stop

				//6б. Реализуйте метод SetNewString, который будет заменять строку
				// на новую

			MyString str3;
			char arr[] = { "It's my string3!" };
			str3.SetNewString(arr);

			std::cout << str3.GetString() << std::endl;

	}

	{
		//Задание 7.  Решите с помощью классов следующую задачу:
		//даны две бочки известного объема. В одной бочке в начальный момент
		//времени содержится спирт (96%), в другой – вода.
		//Кружкой емкостью 1л переливаем итеративно содержимое из одной бочки
		//в другую следующим способом: на каждой итерации
		//зачерпнули из первой бочки -> вылили во вторую
		//зачерпнули из второй бочки -> вылили в первую.
		//Требуется определить номер итерации, на которой концентрация спирта в
		//первой бочке станет меньше 50%.

		int iter = 0;
		Bochka spirt(100, 0.96);
		Bochka water(100, 0);

			while(spirt.getSpirt() > 0.50)			// конец на // {m_volume=100.000000 m_spirt=0.499959260 }
			{
				iter++;
				spirt.Pereliv(water);	//или spirt.Pereliv(water, объем_кружки);
				water.Pereliv(spirt);	// аналогично
				stop
			}
		std::cout << "Количество переливаний:" << iter << std::endl;		// 159
	}	


return 0;

}//end_main

