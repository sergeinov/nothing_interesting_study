// Темы:
// Простое наследование. Виртуальные функции. Абстрактные классы.
// Битовые поля.

#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include <tchar.h>
#include"MyString.h"
#include "Rect.h"
#include "Circle.h"
#include "Shape.h"
#include <cstdarg>
#include "Oct.h"
#include "Hex.h"
#include "Bin.h"

#define	  stop __asm nop

// функция принимает любое количество указателей на строки и объединяет в одно предложение
	MyString _cdecl JoinToSentence(const char* str1, ...)
	{
		// создаем временный объект MyString
		//MyString mystr;

		//char* p = reinterpret_cast<char*>(&n) + sizeof(int);		// вспомогательный указатель на первый элемент
		//int count = 0;											// подсчет символов в строке 
		int sizeAllStr = 0;											// размер предложения
		int sizeStr = 0;											// размер строки
		const char** p = &str1;										// указатель на указатель на первую строку

		// узнаем размер нашей строки
		// идем по количеству указателей
		while (*p)
		{
			// идем по символам
			//while (*p)
			//{
			//	std::cout << *p << " ";
			//	p++;
			//	count++;	
			//}
			std::cout << *p << " ";
			sizeStr = strlen(*p);									// длина строки
			sizeAllStr += sizeStr;									// длина всего предложения // +1 тернарный \0
			p++;													// переходим к следующему параметру
			//p += sizeStr + 1;										// переходим к следующему элементу
			//size += count + 1;									// увеличиваем значение размера предложения	// +1 тернарного нуля
			//count = 0;											// обнуляем для следующей строки
		}

		// создаем память для строк
		char* temp = new char[sizeAllStr + 1];			
		temp[0] = '\0';												// инициализируем временный дин. указатель
		p = &str1;													// указатель на первый параметр

		// соединяем и записываем в указатель предложение
		while (*p)
		{
			strcat(temp, *p);										// добавляем строку в указатель
			//int size = strlen(*p);								// узнаем размер строки
			p++;													// двигаемся к следующему параметру
		}

		// меняем переменную в классе на нашу строку
		MyString mystr(temp);
		
		// удаляем ненужные указатели
		p = nullptr;
		delete[] temp;
		return std::move(mystr);		// вызов move конструктор копирования временного объекта
		// вызов деструктора ~MyString()
	}


int _tmain(int argc, _TCHAR* argv[])
{
	setlocale(LC_ALL, "Rus");
	//Задание 1.Массив объектов класса.
	{
	//Объявите и проинициализируйте массив ar из объектов
	 //типа MyString. 
		const int N=5;
		MyString str1[N] = {MyString("Egor"), MyString("Ivan"),MyString("Kolja") };
  
	//Проверка - печать строк-членов класса
		for (size_t i = 0; i < N; i++)
		{
			std::cout << str1[i].GetString() << std::endl;	// Egor
															// Ivan
															// Ivan
															// empty...
															// empty...
		}
				
	//Замените размер const int N=5; , не изменяя список инициализаторов.
			
	}
	stop

	//Задание 2.Массив указателей на объекты класса.
	{
	//Объявите и проинициализируйте массив arPtr из N
	//указателей на объекты типа MyString (сами объекты 
	//создаются динамически!).
		const int M = 5;
		MyString* str2[M] = {new MyString("Egor"), new MyString("Ivan"), new MyString("Kolja") };
		//Печать строк-членов класса
		for (size_t i = 0; i < M; i++)
		{

				std::cout << str2[i]->GetString() << std::endl;	// Egor
																// Ivan
																// Kolja
		}				
		// для  str2[3]->GetString()  str2[4]->GetString()
		// ошибка // не выделена память, this  = nullptr. str2[3] - (0x00000000 <NULL>)
		// ошибка // не выделена память, this  = nullptr. str2[4] - (0x00000000 <NULL>)

		for (size_t i = 0; i < M; i++)
		{
			delete str2[i];
		}

		//Замените размер const int N=5; , не изменяя список инициализаторов.

	}
		stop

	{
		//Задание 3.Простое наследование.Аргументы конструктора,
		// передаваемые в базовый класс.

		//Создайте иерархию классов:
		//базовый класс Shape (который описывает любую фигуру)
		//и два производных класса Rect и Circle.
		//Подумайте: какие данные и методы нужно ввести в базовый
		//и производные классы (например, любую фигуру можно сделать
		//цветной => в базовом классе можно ввести переменную, которая
		//будет определять цвет фигуры.
		//Подсказка: для хранения цвета объявите перечисление (RED,GREEN,BLUE...);

		Rect rect(1,2,3,4,Shape::GREEN);
		// порядок вызова конструкторов
		// Shape() -> Rect()

		 std::cout << rect.GetColor() << std::endl;

		 Circle circle(-4, 4, 5, Shape::GREEN);
		 // порядок вызова конструкторов
		 // Shape() -> Circle()
	
		 std::cout << circle.GetColor() << std::endl;

		 // порядок деструкторов
		 // ~Shape() > ~Circle() > ~Shape() > ~Rect()

		//В конструкторах производных классов предусмотрите передачу
		//параметра-цвета конструктору базового класса.
		//При создании и уничтожении объекта производного типа определите
		//последовательность вызовов конструкторов и деструкторов базового
		//и производного классов

		 
		stop
	}

//////////////////////////////////////////////////////////////////////

	//Задание 4.Виртуальные функции.
	//4а) Модифицируйте классы Shape,Rect и Circle:
	//добавьте в каждый класс public метод void WhereAmI().
	//Реализация каждой функции должна выводить сообщение 
	//следующего вида "Now I am in class Shape(Rect или Circle)".
	//Выполните приведенный фрагмент, объясните результат.


	{
		Shape s;
		Rect r(-4, 4, 10, -10, Shape::GREEN);
		Circle c(5, 5,4, Shape::YELLOW);

	
		//Метод какого класса вызывается в следующих строчках???
		s.WhereAmI();	//	метод класса Shape
		r.WhereAmI();	//	метод класса Rect
		c.WhereAmI();	//	метод класса Circle
		stop


		Shape* pShape = &s;
		Shape* pRect = &r;
		Shape* pCircle = &c;
    	pShape->WhereAmI();	//	метод класса Shape
		pRect->WhereAmI();	//	метод класса Shape
		pCircle->WhereAmI(); //	метод класса Shape
		stop


		//Заполните ... согласно комментариям
		Shape& rShape = s;	//псевдоним s
		Shape& rRect = r;	//псевдоним r
		Shape& rCircle = c; //псевдоним c
		rShape.WhereAmI();	//вызов посредством rShape	// метод класса Shape
		rRect.WhereAmI();	//вызов посредством	rRect	// метод класса Shape
		rCircle.WhereAmI(); //вызов посредством rCircle	// метод класса Shape
		stop
	}

	//4б) Добавьте в базовый и производные классы виртуальный
	// метод WhereAmIVirtual(). По аналогии с 4а вызовите
	// виртуальный метод посредством объектов, указателей и
	// ссылок, определенных в предыдущем фрагменте.
	//Выполните новый фрагмент, объясните разницу.
	{
		//std::cout << "\nЗадание 4.б" << std::endl;
		Shape s;
		Rect r(-4, 4, 10, -10, Shape::GREEN);
		Circle c(5, 5,4, Shape::YELLOW);

	
		//Метод какого класса вызывается в следующих строчках???
		//По правилу, механизм полиморфизма задействуется, если
		// вызов методу осуществляется посредством указателя или ссылки.
		s.WhereAmIVirtual();	//	метод класса Shape
		r.WhereAmIVirtual();	//	метод класса Rect
		c.WhereAmIVirtual();	//	метод класса Circle
		stop

		
		Shape* pShape = &s;
		Shape* pRect = &r;
		Shape* pCircle = &c;
		pShape->WhereAmIVirtual();	//	метод класса Shape
		pRect->WhereAmIVirtual();	//	метод класса Rect
		pCircle->WhereAmIVirtual(); //	метод класса Circle
		stop


		//Заполните ... согласно комментариям
		Shape& rShape = s;	//псевдоним s
		Shape& rRect = r;	//псевдоним r
		Shape& rCircle = c; //псевдоним c
		rShape.WhereAmIVirtual();	//вызов посредством rShape	// метод класса Shape
		rRect.WhereAmIVirtual();	//вызов посредством	rRect	// метод класса Rect
		rCircle.WhereAmIVirtual(); //вызов посредством rCircle	// метод класса Circle
		stop

		//	~Shape() > ~Circle() > ~Shape() > ~Rect() > ~Shape()
	}


//////////////////////////////////////////////////////////////////////

	//Задание 5.Виртуальные деструкторы.
	//Модифицируйте классы:
	//a) введите соответствующие
	// деструкторы (без ключевого слова virtual).
	//Реализация каждого деструктора
	//должна выводить сообщение следующего вида
	// "Now I am in Shape's destructor!" или
	// "Now I am in Rect's destructor!"
	//Выполните фрагмент. Объясните результат.
	{
		std::cout << "\nЗадание 5.a" << std::endl;
		Shape s;
		Rect r(-4, 4, 10, -10, Shape::GREEN);
		Circle c(5, 5, 4, Shape::YELLOW);

		//Now I am in Circle's destructor!
		//Now I am in Shape's destructor!
		//Now I am in Rect's destructor!
		//Now I am in Shape's destructor!
		//Now I am in Shape's destructor!
	}

	// b) Добавьте в объявление деструкторов ключевое слово virtual 
	//Выполните фрагмент.Объясните разницу.
	{
		std::cout << "\nЗадание 5.б" << std::endl;
		Shape* s = new Shape();
		Shape* r = new Rect(-4, 4, 10, -10, Shape::GREEN);
		Shape* c= new Circle(5, 5, 4, Shape::YELLOW);
		//  Деструкторы не вызываются

		delete s;
		delete r;
		delete c;
	/*	Now I am in Shape's destructor!
		Now I am in Rect's destructor!
		Now I am in Shape's destructor!
		Now I am in Circle's destructor!
		Now I am in Shape's destructor!*/
		stop
	}
	
	// c)//Подумайте: какие конструкторы вызываются в следующей строке?
		//Если в разработанных классов каких-то конструкторов
		//не хватает - реализуйте
 		//Если Вы считаете, что в приведенном фрагменте чего-то
		//не хватает - добавьте
	{
		std::cout << "\nЗадание 5.c" << std::endl;
		Rect r(-4, 4, 10, -10, Shape::GREEN);
		Circle c(5, 5, 4, Shape::YELLOW);
		//Shape* ar[] = { new Shape(r), new Rect(r), new Circle(r), new Circle(), new Rect(c), new Rect() };
		Shape* ar[] = { new Shape(r), new Rect(r), new Circle(), new Rect(c), new Rect() };
		//Вызовите для каждого элемента массива метод WhereAmIVirtual()
		for (size_t i = 0; i < sizeof(ar) / sizeof(Shape*); i++)
		{
			ar[i]->WhereAmIVirtual();
			delete ar[i];
			/*Now I am in class Shape virtual
			Now I am in Shape's destructor!
			Now I am in class Rect virtual
			Now I am in Rect's destructor!
			Now I am in Shape's destructor!
			Now I am in class Circle virtual
			Now I am in Circle's destructor!
			Now I am in Shape's destructor!
			Now I am in class Rect virtual
			Now I am in Rect's destructor!
			Now I am in Shape's destructor!*/
		}

		stop
	}


	//Задание 6*. В чем заключается отличие 1) и 2)
	{
		Shape* pShapes = new Rect[10];//1)
		Rect* pRects = new Rect[10];//2)

		//Попробуйте вызвать метод WhereAmIVirtual() для каждого элемента обоих массивов -
		//в чем заключается проблема???
		for (size_t i = 0; i < 10; i++)
		{
			static_cast<Rect*>(pShapes)[i].WhereAmIVirtual();	// вызов метода Rect
		  // ошибка при вызове pShapes[1].WhereAmIVirtual()
		}

		for (size_t i = 0; i < 10; i++)
		{
			pRects[i].WhereAmIVirtual();	// вызов метода Rect
		}
		

		//Освободите динамически захваченную память
		// удаление массива объектов pShapes
			delete[] pShapes;
		// удаление массива объектов pRects
			delete[] pRects;
	}



//////////////////////////////////////////////////////////////////////

	//Задание 7.Виртуальные функции и оператор разрешения области видимости. 

	{
		Rect r(-4, 4, 10, -10, Shape::GREEN);
		Shape* p = &r;	
		p->WhereAmIVirtual();  // вызов метода Rect
		stop


		//4a Оператор разрешения области видимости.
		//Посредством объекта r и указателя p вызовите виртуальную функцию
		//WhereAmIVirtual()класса Shape

		p->Shape::WhereAmIVirtual(); // Вызов метода Shape

		// деструктор Rect
		// Деструктор Shape
	}


//////////////////////////////////////////////////////////////////////

	//Задание 8.Чисто виртуальные функции. 
	//Введите в базовый класс метод void Inflate(int); Подумайте:
	//можно ли реализовать такой метод для базового класса? => как его нужно объявить.
	//Реализуйте этот метод для производных классов.
	{
		// при виртуальном методе базовый класс становится абстрактным, что не позволяет создать обьект такого типа.
		/*Rect r(-4, 4, 10, -10, Shape::GREEN);
		Shape* p = &r;
		p->Inflate(5);
		Circle c(5, 5, 4, Shape::YELLOW);
		p = &c;
		p->Inflate(5);
		stop*/
	}



//////////////////////////////////////////////////////////////////////
	//Задание 9. Создайте глобальную функцию, которая будет принимать любое
	//количество указателей на строки, а возвращать объект MyString,
	//в котором строка будет конкатенацией параметров
	{
		MyString str = JoinToSentence("My ", "name ", " is ", "Sergey!", nullptr);
		stop
	}
////////////////////////////////////////////////////////////////////////
/*
	//Задание 10.Объединения (union) C++. Битовые поля.
	//1.
	//Создайте следующие классы для различных представлений значений байта:
	//Bin - для двоичного представления
	//Hex - для шестнадцатерчного представления
	//Oct - для восьмеричного представления.
	//Подсказка 1: - для удобства используйте битовые поля.
	//Подсказка 2: - конструкторов в таких вспомогательных классах быть не должно,
	//так как все они будут членами объединения (union).
	//2.
	//В каждом классе введите метод Show, который должен выводить значение в
	//соответствующем виде
	//3.
	//Посредством объединения MyByte предоставьте пользователю возможность манипулировать
	//одним и тем же значением по-разному:
	//а) выводить: десятичное, шестнадцатеричное, восьмеричное, двоичное значение байта 
	//          а также символ, соответствующий хранимому значению (если есть соответствие);
	//б) выводить отдельные (указанные посредством параметра) шестнадцатеричные,
	//			восьмеричные, двоичные цифры;
	//в) изменять отдельные двоичные, восьмеричные или шестнадцатеричные цифры;

	MyByte byte(0x1f);
	byte.ShowHex();
	byte.ShowBin();
	//...


*/
	return 0;
}//endmain

