/*************************************************************
	Практическое занятие №3-курс-С110. Структуры
//динамический массив структур
//поиск
//сортировка
//сохранение в файле
//чтение из файла
*************************************************************/

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <math.h>
#include "book.h"

//#pragma pack(push,1)	// отключение выравнивания структуры

#define	  stop __asm nop	

// создание экземпляра в глобальной области
BOOK book1;							// инициализация нулями  

int main()
{
	setlocale(LC_ALL, "Russian");
	{
		using namespace std;
		//Тема "Старые" потоковые функции стандартной библиотеки
		//Задание 1. С помощью функции scanf сформирйуте три коэффициента: A,B,C
		printf("Задание 1\n");
		int a;
		int b;
		int c;
		
		printf("Введите значения A, B, C: ");
		scanf("%d %d %d", &a, &b, &c);
		//printf("%4d %4d %4d", a, b, c);

		//Задание 2. Выведите (красиво!) таблицу значений y=A*x*x + B*x + C
		//при изменении x в диапазоне -2 до +2 с шагом 0.5
		double y;
		float x = -2;
		float step = 0.5;
		char space = ' ';
		char lineVert = '|';

		printf("\n\n");
		printf("\t%c %6cx%6c %c %6cy%-6c %c", lineVert, space, space, lineVert, space, space, lineVert);
		printf("\n\t_________________________________");
		while (!(x == 2))
		{
			y = ((a * pow(x, 2)) + ((b * x) + c));
			printf("\n\t%c x = %6.1f %4c y = %6.2f %4c", lineVert, x, lineVert, y, lineVert);
			x += step;
		}
		printf("\n\t_________________________________");
	}
	//Тема. Структуры С.	
//Задание 1.1 Объявите структуру BOOK, описывающую книгу
//(автор, заглавие, год издания, цена, категория…).
//Подумайте: какого типа могут быть поля структуры.
//Подсказка: объявление структуры рекомендуется выносить
//в заголовочный файл.
	{

		printf("\n\nЗадание 1.2\n");
		//Задание 1.2. Создайте разными способами (глобальный, локальный, статический,
		//динамический) экземпляры (объекты) типа BOOK (без инициализации).
		//Определите - сколько памяти отводит компилятор под каждый
		//такой объект. Как инициализируются (или не инициализируются) поля
		//структуры. Подумайте: от чего зависит объем выделяемой памяти?

		// создание структуры в глобальной области
		printf("%d", sizeof(book1));		// 176 байт

		// локальная структура
		BOOK2 book3;							// инициализация мусором
		printf("\n%d", sizeof(book3));		// 176 байт

		// статическая локальная структура
		static BOOK2 book2;					// инициализация нулями
		printf("\n%d", sizeof(book2));		// 176 байт

		// создание одиночной динамической структуры
		BOOK2* book4 = new BOOK2;				// инициализация мусором
		printf("\n%d", sizeof*(book4));		// 176 байт

		// одномерный встроенный массив структур
		const int N = 5;
		BOOK2 book5[N] = { 0 };				// обнуляем все поля массив структур // проинициализировать поля можно только при создании экземпляра
		printf("\n%d", sizeof(book5));		// 880 байт
		printf("\n%d", (sizeof(book5) / sizeof(BOOK2)));		// 5

		//Задание 1.3. Напишите функцию, выводящую на экран реквизиты книги.
		//Подумайте: как эффективнее передавать экземпляр BOOK в функцию.
		//Для вывода на консоль используйте функцию стандартной библиотеки
		//printf
		printf("\n\nЗадание 1.3\n");
		BOOK2 book6;
		printBOOK2(&book6);


		//Задание 1.4. Напишите функцию для формирования полей структуры.
		//Для ввода используйте функцию стандартной библиотеки scanf
		//Замечание: неплохо заложить в такую функцию возможность проверки
		//корректности введенного значения, например, год издания не может быть
		//меьше, чем... (год появления письменности), категорию пользователь
		//должен выбирать из существующих, цена не может быть отрицательной...
		printf("\n\nЗадание 1.4\n");
		BOOK2 book7;
		editBook2(&book7);
		printf("\nВывод...\n");
		printBOOK2(&book7);

		//Используйте структуру BOOK, созданную в предыдущем задании.
		//Для этого достаточно переписать и подключить к проекту файлы
		//book.h и book.cpp
	}

	{
		//////////////////////////////////////////////////////////////
		//Задание 2. Создаем «картотеку».
		//«Картотека» - это массив структур => нужно такой массив создать.
		//Замечание: размер массива придется увеличиватьпо мере добавления книг =>
		//кКаким должен быть такой массив???
		printf("\n\nЗадание 2\n");

		unsigned int N = 5;
		BOOK** book = new BOOK*[N];		// массив указателей на структуры
		int code = 0;					// для записи кода команды 
		int count = 0;					// счетчик книг
		//Пользователь должен иметь возможность по своему желанию выполнять
		//разные действия с картотекой => нужно такую возможность ему
		//предоставить: это может выглядеть как вывод "меню" (перечень
		//возможных действий и соответствующих реакций пользователя), например:
		//Распечатать содержимое картотеки (1)
		//Ввести новую книгу (2)
		//Удалить существующую(ие) (3)
		//Записать текущее содержимое картотеки в файл (4)
		//Считать из файла содержимое в картотеку (5)
		//...
		//Выход из программы (...)
		//Реализуйте посредством функций разные возможности работы с картотекой

		//printBOOK(&card, N);
		outputMenu();
		/*do
		{
			printf("\nВведите команду: ");
			scanf("%d", &code);
			switch (code)
			{
			case 1:
				printBOOK(book, N);
			case 2:
				//addBook(book, count);
				card.count++;
				break;
			case 3:
			case 4:
			case 5:
			case 6:
				outputMenu();
				break;
			case 7:
				printf("\nВыход из программы!\n");
			default:
				break;
			}
			

		} while (!(code == 7));
		
		// освобождаем память от массива структур
		for (size_t i = 0; i < N; i++)
		{
			delete book[i];
		}
		delete[] book;
		*/

		//Подсказка1: для файлового ввода/вывода используйте функции fprintf и fscanf
		//(заголовочный файл <cstdio>



		// Подсказка2: удобно в качестве первого данного в файле хранить количество
		// книг в картотеке
		//Если файл существует и его удалось открыть
		//if()
		//{
		//Чтение данных из файла
		//а) считали количество элементов
		//б) создали массив требуемой размерности
		//в) считали данные из файла в массив
		//}



	}

	//****************************************************************
	{
		//Задание 3. Предоставьте пользователю возможность выводить перечень книг
		//в определенном порядке => напишите функцию (функции) сортировки массива
		//по любому из полей структуры.
		//Замечание: признак - "по какому полю сортируем" можно ввести с помощью
		//перечисления.


	}
	return 0;
}