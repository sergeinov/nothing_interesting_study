/*************************************************************
	Практическое занятие №3-курс-С110. Структуры
//динамический массив структур
//поиск
//сортировка
//сохранение в файле
//чтение из файла
*************************************************************/

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <math.h>
#include "book.h"

//#pragma pack(push,1)	// отключение выравнивания структуры

#define	  stop __asm nop	

// создание экземпляра в глобальной области
BOOK book1;							// инициализация нулями  

void main()
{
	setlocale(LC_ALL, "Russian");
	{
		using namespace std;
		//Тема "Старые" потоковые функции стандартной библиотеки
		//Задание 1. С помощью функции scanf сформирйуте три коэффициента: A,B,C
		printf("Задание 1\n");
		int a;
		int b;
		int c;
		
		printf("Введите значения A, B, C: ");
		scanf("%d %d %d", &a, &b, &c);
		//printf("%4d %4d %4d", a, b, c);

		//Задание 2. Выведите (красиво!) таблицу значений y=A*x*x + B*x + C
		//при изменении x в диапазоне -2 до +2 с шагом 0.5
		double y;
		float x = -2;
		float step = 0.5;
		char space = ' ';
		char lineVert = '|';

		printf("\n\n");
		printf("\t%c %6cx%6c %c %6cy%-6c %c", lineVert, space, space, lineVert, space, space, lineVert);
		printf("\n\t_________________________________");
		while (!(x == 2))
		{
			y = ((a * pow(x, 2)) + ((b * x) + c));
			printf("\n\t%c x = %6.1f %4c y = %6.2f %4c", lineVert, x, lineVert, y, lineVert);
			x += step;
		}
		printf("\n\t_________________________________");
	}
	//Тема. Структуры С.	
//Задание 1.1 Объявите структуру BOOK, описывающую книгу
//(автор, заглавие, год издания, цена, категория…).
//Подумайте: какого типа могут быть поля структуры.
//Подсказка: объявление структуры рекомендуется выносить
//в заголовочный файл.
	{

		printf("\n\nЗадание 1.2\n");
		//Задание 1.2. Создайте разными способами (глобальный, локальный, статический,
		//динамический) экземпляры (объекты) типа BOOK (без инициализации).
		//Определите - сколько памяти отводит компилятор под каждый
		//такой объект. Как инициализируются (или не инициализируются) поля
		//структуры. Подумайте: от чего зависит объем выделяемой памяти?

		// создание структуры в глобальной области
		printf("%d", sizeof(book1));		// 176 байт

		// локальная структура
		BOOK book3;							// инициализация мусором
		printf("\n%d", sizeof(book3));		// 176 байт

		// статическая локальная структура
		static BOOK book2;					// инициализация нулями
		printf("\n%d", sizeof(book2));		// 176 байт

		// создание одиночной динамической структуры
		BOOK* book4 = new BOOK;				// инициализация мусором
		printf("\n%d", sizeof*(book4));		// 176 байт

		// одномерный встроенный массив структур
		const int N = 5;
		BOOK book5[N] = { 0 };				// обнуляем все поля массив структур // проинициализировать поля можно только при создании экземпляра
		printf("\n%d", sizeof(book5));		// 880 байт
		printf("\n%d", (sizeof(book5) / sizeof(BOOK)));		// 5

		//Задание 1.3. Напишите функцию, выводящую на экран реквизиты книги.
		//Подумайте: как эффективнее передавать экземпляр BOOK в функцию.
		//Для вывода на консоль используйте функцию стандартной библиотеки
		//printf
		printf("\n\nЗадание 1.3\n");
		BOOK book6;
		printBOOK(&book6);


		//Задание 1.4. Напишите функцию для формирования полей структуры.
		//Для ввода используйте функцию стандартной библиотеки scanf
		//Замечание: неплохо заложить в такую функцию возможность проверки
		//корректности введенного значения, например, год издания не может быть
		//меьше, чем... (год появления письменности), категорию пользователь
		//должен выбирать из существующих, цена не может быть отрицательной...
		printf("\n\nЗадание 1.4\n");
		BOOK book7;
		editBook(&book7);
		printf("\nВывод...\n");
		printBOOK(&book7);

		//Используйте структуру BOOK, созданную в предыдущем задании.
		//Для этого достаточно переписать и подключить к проекту файлы
		//book.h и book.cpp
	}

	{
		printf("\n\nЗадание 2\n");
			//Задание 2. Создаем «картотеку».
			//«Картотека» - это массив структур => нужно такой массив создать.
			//Замечание: размер массива придется увеличиватьпо мере добавления книг =>
			//кКаким должен быть такой массив???


			//Пользователь должен иметь возможность по своему желанию выполнять
			//разные действия с картотекой => нужно такую возможность ему
			//предоставить: это может выглядеть как вывод "меню" (перечень
			//возможных действий и соответствующих реакций пользователя), например:
			//Распечатать содержимое картотеки (1)
			//Ввести новую книгу (2)
			//Удалить существующую(ие) (3)
			//Записать текущее содержимое картотеки в файл (4)
			//Считать из файла содержимое в картотеку (5)
			//...
			//Выход из программы (...)


			//Реализуйте посредством функций разные возможности работы с картотекой




			//Подсказка1: для файлового ввода/вывода используйте функции fprintf и fscanf
			//(заголовочный файл <cstdio>



			// Подсказка2: удобно в качестве первого данного в файле хранить количество
			// книг в картотеке
			//Если файл существует и его удалось открыть
			//if()
			//{
			//Чтение данных из файла
			//а) считали количество элементов
			//б) создали массив требуемой размерности
			//в) считали данные из файла в массив
			//}



	}

	//****************************************************************
	//Задание 3. Предоставьте пользователю возможность выводить перечень книг
	//в определенном порядке => напишите функцию (функции) сортировки массива
	//по любому из полей структуры.
	//Замечание: признак - "по какому полю сортируем" можно ввести с помощью
	//перечисления.



}