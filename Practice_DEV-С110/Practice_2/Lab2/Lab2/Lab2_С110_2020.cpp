
/*************************************************************
	Практическое занятие №2 курс С110. Функции.
	Указатели на функции

*************************************************************/
#include <iostream>
#include <tchar.h>
//#include <cstdio>
//#include <cstdarg>
#include "other.h"
#include <cmath>


#define	  stop __asm nop
				
int _tmain()
{
	{
		setlocale(LC_ALL, "Rus");
		//Задание 1. 
		//Указатели на массивы в качестве аргументов.
		//Напишите два варианта функции печати элементов
		//1. во встроенном двумерном массиве
		//int ar[N][M] = {список инициализаторов};//подумайте - как и где должны быть заданы N и M
		//PrintArray(ar, ... может быть, понадобится передать еще какие-нибудь данные);
		std::cout << "Задание 1.а..." << std::endl;
		int ar[N][M] = { {1,2,3,4},
						 {4,5,6,7},
						 {12,13,14,15},
						 {21,22,23,24} 
		};
		PrintArray(ar, N);			// печать массива
			
		//2. в динамическом двумерном массиве (обе размерности вычисляются)
		std::cout << "\nЗадание 1.б ..." << std::endl;

		// вычисляются N  и  M
		int** par2 = new int*[N];
		for (size_t i = 0; i < N; i++)
		{
			par2[i] = new int[M];
		}
		PrintArray2(par2, N, M);


		std::cout << "\nОсвобождаем память динамического двухмерного..." << std::endl;
		for (size_t i = 0; i < N; i++)
		{
			delete[] par2[i];
		}
		delete[] par2;
		par2 = 0;

	}
/////////////////////////////////////////////////////////////////////////////
	//Задание 2.
	std::cout << "\nЗадание 2..." << std::endl;
	//Передача указателя на встроенный массив в качестве параметра функции.
			//Напишите две взаимодополняющие друг друга функции:
			//1.  ... DayOfYear(...)
			//- преобразует день месяца (число,месяц и год задаются в качестве параметров)
			//в порядковый день года(возвращаемое значение)
			//2. ... DayOfMonth(...) - функция преобразует порядковый день года в день месяца
			// (принимает год и порядковый день года в качестве параметров и должна сформировать
			// день месяца и номер месяца и каким-то образом сообщить эти значения вызывающей процедуре)

			//Проверьте работоспособность обеих функций с помощью следующего фрагмента:


			//В процессе вычислений Вам придется учитывать "високосный - невисокосный" год.
			//для проверки "високосности" года имеет смысл создать функцию (isLeepYear)
			//Для этого предлагается в каждую функцию в качестве одного из параметров передавать
			//данные приведенного ниже двухмерного массива nDayTab

	int nDayTab[2][12] = {
		{31,28,31,30,31,30,31,31,30,31,30,31},		//невисокосный год
		{31,29,31,30,31,30,31,31,30,31,30,31} };	//високосный год

	int day = 12;
	int month = 10;
	int year = 2000;
	int dayOfYear = 0;		// для записи результата  порядкового дня года
	
	//Вызов функции DayOfYear
	dayOfYear = DayOfYear(day, month, year, nDayTab);
	std::cout << "Порядковый день года: " << dayOfYear << std::endl;

	//Проверка результата обратной функцией DayOfMonth
	int resDayMonth;
	int resMonth;
	DayOfMonth(year, dayOfYear, nDayTab, &resDayMonth, &resMonth);
	std::cout << "День месяца: " << resDayMonth << " Месяц: " << resMonth << std::endl;

	stop
/////////////////////////////////////////////////////////////////////////////
	//Задание 3.
	//Задание 3а. Функции с переменным числом параметров.
	//Напишите функцию (дана заготовка VarArgs, не использующая
	// макросы), которая принимает переменное число аргументов
	// типа int и выводит на печать число принятых параметров и
	// их значения.
	// Признаком конца списка является нулевое значение.
	{
		std::cout << "\nЗадание 3..." << std::endl;

		int nN1 = 5, nN2 = 11, nN3 = 4, nN4 = 7, nN5 = -1;
		VarArgs(nN1,0);
		std::cout << std::endl;
		VarArgs(nN1,nN2,0);
		std::cout << std::endl;
		VarArgs(nN1,nN2,nN3,nN4,nN5,0);
		stop
		std::cout << std::endl;

		//Задание 3б. Модифицируйте функцию 3а с помощью макросов
		// va_start, va_arg, va_end
		std::cout << "\nЗадание 3.б..." << std::endl;

		VarArgs2(nN1, 0);
		std::cout << std::endl;
		VarArgs2(nN1, nN2, 0);
		std::cout << std::endl;
		VarArgs2(nN1, nN2, nN3, nN4, nN5, 0);

	}
///////////////////////////////////////////////////////////////////
	//Тема Указатели на функции
	{
		//Задание 4. Указатель на функцию. "Калькулятор".
		//Напишите функции:
		//1)Sum - принимает два значения double и возвращает сумму
		//этих значений
		//2)Sub- принимает два значения double и возвращает разность
		//этих значений
		//3)Mul - *
		//4)Div - /
		//5)а для возведения в степень можете использовать функцию стандартной библиотеки
		//		- pow(). Подсказка 1: прототип функции находится в <cmath>.
		//		Подсказка 2: стандартная библиотека предоставляет несколько перегруженных
		//		вариантов этой функции, а Вам потребуется сформировать указатель на 
		//		double pow(double, double);

		//Предоставьте пользователю	следующую возможность:
		//пока пользователь хочет пользоваться услугами Вашего калькулятора,
		//он может вводить два значения и знак операции
		//а Вы выводите результат. Результат получаете посредством вызова
		//соответствующей Вашей функции по указателю.
		//Предусмотрите возможность ввода непредусмотренного знака операции
		std::cout << "\n\nЗадание 4..." << std::endl;
		char question;								// для завершения цикла
		char sign;									// оператор выражения
		double number1, number2;					// входные параметры функции
		double res;									// результат/вывод
		double (*pf)(double, double) = nullptr;		// указатель на функцию  pf

		std::cout << "Калькулятор." << std::endl;
		do
		{
			std::cout << "Введите первое число:" << std::endl;
			std::cin >> number1;
			std::cout << "Введите знак:" << std::endl;
			std::cin >> sign;
			std::cout << "Введите второе число:" << std::endl;
			std::cin >> number2;

			switch (sign) {
			case '+':
				pf = &Sum;							// присвоили указателю адрес функции
				res = (*pf)(number1, number2);		//  вызвали функцию и присвоили результат res
				std::cout << res << std::endl;		//  распечатали результат res
				break;

			case '-':
				pf = &Sub;							// присвоили указателю адрес функции
				res = (*pf)(number1, number2);		//  вызвали функцию и присвоили результат res
				std::cout << res << std::endl;		//  распечатали результат res
				break;
			case '*':
				pf = &Mul;							// присвоили указателю адрес функции
				res = (*pf)(number1, number2);		//  вызвали функцию и присвоили результат res
				std::cout << res << std::endl;		//  распечатали результат res
				break;
			case '/':
				pf = &Div;							// присвоили указателю адрес функции
				res = (*pf)(number1, number2);		//  вызвали функцию и присвоили результат res
				std::cout << res << std::endl;		//  распечатали результат res
				break;
			case '^':
				pf = &PowDouble;							// присвоили указателю адрес функции
				res = (*pf)(number1, number2);		//  вызвали функцию и присвоили результат res
				std::cout << res << std::endl;		//  распечатали результат res
				break;
			default:
				std::cout << "Неверный знак операции!" << std::endl;
				break;
			}
			stop

			std::cout << "Нажмите 'q' для выхода. Или любую другую для продолжения" << std::endl;
			std::cin >> question;
		} while (!(question == 'q'));
		
		// обнуляем указатель
		pf = 0;
	}
///////////////////////////////////////////////////////////////////
	//Задание 5. Указатель на функцию в качестве аргумента.
	//Дана заготовка функции сортировки любых объектов - Sort.
	//Функция принимает следующие параметры:
	//1) указатель на первый сортируемый элемент
	//2) количество сортируемых элементов
	//3) размер элемента в байтах
	//4) указатель на функцию перестановки элементов
	//5) указатель на функцию сравнения элементов

	//5a. Напишите функцию перестановки двух целых значений -
	// SwapInt, которая принимает два void указателя и 
	//меняет значения местами

	//Напишите функцию сравнения двух целых значений -
	// CmpInt, которая принимает два void указателя и
	//возвращает int результат сравнения: 
	//<0 - первый элемент меньше, чем второй
	//=0 - равны
	//>0 - первый элемент больше, чем второй
	/*
		int nAr[]=...	//массив для сортировки

		//Печать исходного массива

		//Вызов сортировки
		int nTotal=...			//количество элементов в массиве
		Sort(reinterpret_cast<char*>(&nAr[0]), nTotal, sizeof(int), SwapInt, CmpInt);

		//Печать результатов сортировки

		stop
	*/
	/*
	//Задание 5б. По аналогии с 5а создайте вспомогательные
	//функции - SwapDouble и CmpDouble и вызовите функцию Sort
	//для сортировки массива вещественных значений.
	*/
	/*
	//Задание 5в*. По аналогии с 5а создайте вспомогательные
	//функции - SwapStr и CmpStr и вызовите функцию Sort
	//для сортировки массива указателей на строки.
	
	const char* arStr[] = { "QQQ", "SDF", "ABC","Abba", "ENFR","En",. . . };
	//Замечание:
	//в массиве линейно лежат АДРЕСА строк, надо передать АДРЕС массива, 
	// но предварительно необходимо снять константность (!!!)
	Sort(reinterpret_cast<char*>(const_cast<???>(&arStr[0])), nTotal, sizeof(???), SwapStr, CmpStr);
	*/
///////////////////////////////////////////////////////////////////
	{
		std::cout << "\nЗадание 6..." << std::endl;
		//Задание 6. Массивы указателей на функцию.
		//Напишите несколько функций вида
		//const char* GetString1();
		//const char* GetString2();
		//		...., каждая из функций возвращает указатель на свою строку
		//(подумайте - какой адрес Вы имеете право возвращать из функции)
		//char mas[] = { "Вызов функции GetString" };							// строка для функции

		//Объявите и проинициализируйте массив указателей на функции
		//GetString1,GetString2...
		const char* res2 = nullptr;																// указатель для  записи результата
		const char* (*FuncAr[]) (void) = {GetString0, GetString1, GetString2, GetString3};		// массив указателей на функции

		//Введите номер функции, которую Вы хотите вызвать:
		int n;
		std::cout << "Введите номер функции 0,1,2 или 3: " << std::endl;
		std::cin >> n;

		// Вызовите функцию
		if (n >=0 && (sizeof(FuncAr) / sizeof(char* (*) (void))))
		{
			const char* res2 = FuncAr[n]();				// вызов и присваивание адреса

			//Распечатайте результат
			while (*res2)
			{
				std::cout << *res2;
				res2++;
			}
		}


		// удаляем указатель на массив функций
		// delete FuncAr;			// ошибка

	}
////////////////////////////////////////////////////////////////////////////
	//Задание 7*.
	//Создайте одномерный массив (размерность вычисляется в процессе
	//выполнения программы), заполните его значениями.
	//Напишите функцию, которая добавляет в массив новое значение только (!) при условии,
	//что такого значения в массиве еще нет. 
	//Подсказка: при этом размер  массива должен увеличиться!
	//Для проверки напишите функцию, которая выводит значения всех элементов на экран
///////////////////////////////////////////////////////////////////////////

	//Задание 8.  
	{
		std::cout << "\nЗадание 8..." << std::endl;
		//Рекурсивные функции.
		
		

		//8.1.Написать рекурсивную функцию вычисления суммы первых N натуральных чисел. 
		int value = 7;
		value = sumValue(value);
		std::cout << "сумма натурального числа равна = " << value << std::endl;

		//8.2.Написать рекурсивную функцию вычисления количества цифр 10-чного натурального числа 
		int value2 = 4563867234;
		int result = 0;
		result = quantityNumber(value2);
		std::cout << "\nколичество цифр натурального числа: "  << result << std::endl;

		//8.3.Написать рекурсивную функцию для вывода на экран строки в обратном порядке. 
		const char str[] = "Ромашка";
		std::cout << "\nРомашка" << std::endl;
		reversStr(str);

		//8.4.Написать рекурсивную функцию для вывода на экран строки в прямом (!) порядке.

		stop
	}

	return 0;
}//main

