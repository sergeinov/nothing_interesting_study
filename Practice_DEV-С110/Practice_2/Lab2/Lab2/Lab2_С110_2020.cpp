
/*************************************************************
	Практическое занятие №2 курс С110. Функции.
	Указатели на функции

*************************************************************/
#include <iostream>
#include <tchar.h>
//#include <cstdio>
//#include <cstdarg>
#include "other.h"
#include <cmath>


#define	  stop __asm nop
				
int _tmain()
{
	{
		setlocale(LC_ALL, "Rus");
		//Задание 1. 
		//Указатели на массивы в качестве аргументов.
		//Напишите два варианта функции печати элементов
		//1. во встроенном двумерном массиве
		//int ar[N][M] = {список инициализаторов};//подумайте - как и где должны быть заданы N и M
		//PrintArray(ar, ... может быть, понадобится передать еще какие-нибудь данные);
		std::cout << "Задание 1.а..." << std::endl;
		int ar[N][M] = { {1,2,3,4},
						 {4,5,6,7},
						 {12,13,14,15},
						 {21,22,23,24} 
		};
		PrintArray(ar, N);			// печать массива
			
		//2. в динамическом двумерном массиве (обе размерности вычисляются)
		std::cout << "\nЗадание 1.б ..." << std::endl;

		// вычисляются N  и  M
		int** par2 = new int*[N];
		for (size_t i = 0; i < N; i++)
		{
			par2[i] = new int[M];
		}
		PrintArray2(par2, N, M);


		std::cout << "\nОсвобождаем память динамического двухмерного..." << std::endl;
		for (size_t i = 0; i < N; i++)
		{
			delete[] par2[i];
		}
		delete[] par2;
		par2 = 0;

	}
/////////////////////////////////////////////////////////////////////////////
	//Задание 2.
	std::cout << "Задание 2..." << std::endl;
	//Передача указателя на встроенный массив в качестве параметра функции.
			//Напишите две взаимодополняющие друг друга функции:
			//1.  ... DayOfYear(...)
			//- преобразует день месяца (число,месяц и год задаются в качестве параметров)
			//в порядковый день года(возвращаемое значение)
			//2. ... DayOfMonth(...) - функция преобразует порядковый день года в день месяца
			// (принимает год и порядковый день года в качестве параметров и должна сформировать
			// день месяца и номер месяца и каким-то образом сообщить эти значения вызывающей процедуре)

			//Проверьте работоспособность обеих функций с помощью следующего фрагмента:


			//В процессе вычислений Вам придется учитывать "високосный - невисокосный" год.
			//для проверки "високосности" года имеет смысл создать функцию (isLeepYear)
			//Для этого предлагается в каждую функцию в качестве одного из параметров передавать
			//данные приведенного ниже двухмерного массива nDayTab

	int nDayTab[2][12] = {
		{31,28,31,30,31,30,31,31,30,31,30,31}, //невисокосный год
		{31,29,31,30,31,30,31,31,30,31,30,31} };	//високосный год

	//Вызов функции DayOfYear
	//...


	//Проверка результата обратной функцией DayOfMonth
	//...

	stop
/////////////////////////////////////////////////////////////////////////////
	//Задание 3.
	//Задание 3а. Функции с переменным числом параметров.
	//Напишите функцию (дана заготовка VarArgs, не использующая
	// макросы), которая принимает переменное число аргументов
	// типа int и выводит на печать число принятых параметров и
	// их значения.
	// Признаком конца списка является нулевое значение.
	{
		std::cout << "Задание 3..." << std::endl;

		int nN1 = 5, nN2 = 11, nN3 = 4, nN4 = 7, nN5 = -1;
		VarArgs(nN1,0);
		std::cout << std::endl;
		VarArgs(nN1,nN2,0);
		std::cout << std::endl;
		VarArgs(nN1,nN2,nN3,nN4,nN5,0);
		stop
		std::cout << std::endl;

		//Задание 3б. Модифицируйте функцию 3а с помощью макросов
		// va_start, va_arg, va_end
		std::cout << "\nЗадание 3.б..." << std::endl;

		VarArgs2(nN1, 0);
		std::cout << std::endl;
		VarArgs2(nN1, nN2, 0);
		std::cout << std::endl;
		VarArgs2(nN1, nN2, nN3, nN4, nN5, 0);

	}
///////////////////////////////////////////////////////////////////
	//Тема Указатели на функции
	{
		//Задание 4. Указатель на функцию. "Калькулятор".
		//Напишите функции:
		//1)Sum - принимает два значения double и возвращает сумму
		//этих значений
		//2)Sub- принимает два значения double и возвращает разность
		//этих значений
		//3)Mul - *
		//4)Div - /
		//5)а для возведения в степень можете использовать функцию стандартной библиотеки
		//		- pow(). Подсказка 1: прототип функции находится в <cmath>.
		//		Подсказка 2: стандартная библиотека предоставляет несколько перегруженных
		//		вариантов этой функции, а Вам потребуется сформировать указатель на 
		//		double pow(double, double);

		//Предоставьте пользователю	следующую возможность:
		//пока пользователь хочет пользоваться услугами Вашего калькулятора,
		//он может вводить два значения и знак операции
		//а Вы выводите результат. Результат получаете посредством вызова
		//соответствующей Вашей функции по указателю.
		//Предусмотрите возможность ввода непредусмотренного знака операции
		std::cout << "Задание 4..." << std::endl;
		char question;								// для завершения цикла
		char sign;									// оператор выражения
		double number1, number2;					// входные параметры функции
		double res;									// результат/вывод
		double (*pf)(double, double) = nullptr;		// указатель на функцию  pf

		std::cout << "\nКалькулятор." << std::endl;
		do
		{
			std::cout << "Введите первое число:" << std::endl;
			std::cin >> number1;
			std::cout << "Введите знак:" << std::endl;
			std::cin >> sign;
			std::cout << "Введите второе число:" << std::endl;
			std::cin >> number2;

			switch (sign) {
			case '+':
				pf = &Sum;							// присвоили указателю адрес функции
				res = (*pf)(number1, number2);		//  вызвали функцию и присвоили результат res
				std::cout << res << std::endl;		//  распечатали результат res
				break;

			case '-':
				pf = &Sub;							// присвоили указателю адрес функции
				res = (*pf)(number1, number2);		//  вызвали функцию и присвоили результат res
				std::cout << res << std::endl;		//  распечатали результат res
				break;
			case '*':
				pf = &Mul;							// присвоили указателю адрес функции
				res = (*pf)(number1, number2);		//  вызвали функцию и присвоили результат res
				std::cout << res << std::endl;		//  распечатали результат res
				break;
			case '/':
				pf = &Div;							// присвоили указателю адрес функции
				res = (*pf)(number1, number2);		//  вызвали функцию и присвоили результат res
				std::cout << res << std::endl;		//  распечатали результат res
				break;
			case '^':
				pf = &PowDouble;							// присвоили указателю адрес функции
				res = (*pf)(number1, number2);		//  вызвали функцию и присвоили результат res
				std::cout << res << std::endl;		//  распечатали результат res
				break;

				/*double (*pf)(double, double) = &Sum;
				double res1 = (*pf)(5.5, 4);
				std::cout << res1 << std::endl;

				double (*pf)(double, double) = &Sub;
				double res1 = (*Sum)(5.5, 4);
				std::cout << res1 << std::endl;

				double (*pf)(double, double) = &Mul;
				double res1 = (*Sum)(5.5, 4);
				std::cout << res1 << std::endl;

				double (*pf)(double, double) = &PowDouble;
				double res1 = (*Sum)(5.5, 4);
				std::cout << res1 << std::endl;

				double (*pf)(double, double) = &Sum;
				double res1 = (*Sum)(5.5, 4);
				std::cout << res1 << std::endl;*/
			default:
				std::cout << "Неверный знак операции!" << std::endl;
				break;
			}
			stop

			std::cout << "Нажмите 'q' для выхода. Или любую другую для продолжения" << std::endl;
			std::cin >> question;
		} while (!(question == 'q'));
		
		// обнуляем указатель
		pf = 0;
	}
///////////////////////////////////////////////////////////////////
	//Задание 5. Указатель на функцию в качестве аргумента.
	//Дана заготовка функции сортировки любых объектов - Sort.
	//Функция принимает следующие параметры:
	//1) указатель на первый сортируемый элемент
	//2) количество сортируемых элементов
	//3) размер элемента в байтах
	//4) указатель на функцию перестановки элементов
	//5) указатель на функцию сравнения элементов

	//5a. Напишите функцию перестановки двух целых значений -
	// SwapInt, которая принимает два void указателя и 
	//меняет значения местами

	//Напишите функцию сравнения двух целых значений -
	// CmpInt, которая принимает два void указателя и
	//возвращает int результат сравнения: 
	//<0 - первый элемент меньше, чем второй
	//=0 - равны
	//>0 - первый элемент больше, чем второй
	/*
		int nAr[]=...	//массив для сортировки

		//Печать исходного массива

		//Вызов сортировки
		int nTotal=...			//количество элементов в массиве
		Sort(reinterpret_cast<char*>(&nAr[0]), nTotal, sizeof(int), SwapInt, CmpInt);

		//Печать результатов сортировки

		stop
	*/
	/*
	//Задание 5б. По аналогии с 5а создайте вспомогательные
	//функции - SwapDouble и CmpDouble и вызовите функцию Sort
	//для сортировки массива вещественных значений.
	*/
	/*
	//Задание 5в*. По аналогии с 5а создайте вспомогательные
	//функции - SwapStr и CmpStr и вызовите функцию Sort
	//для сортировки массива указателей на строки.
	
	const char* arStr[] = { "QQQ", "SDF", "ABC","Abba", "ENFR","En",. . . };
	//Замечание:
	//в массиве линейно лежат АДРЕСА строк, надо передать АДРЕС массива, 
	// но предварительно необходимо снять константность (!!!)
	Sort(reinterpret_cast<char*>(const_cast<???>(&arStr[0])), nTotal, sizeof(???), SwapStr, CmpStr);
	*/
///////////////////////////////////////////////////////////////////
	/*
	//Задание 6. Массивы указателей на функцию.
	//Напишите несколько функций вида
	//const char* GetString1();
	//const char* GetString2();
	//		...., каждая из функций возвращает указатель на свою строку
	//(подумайте - какой адрес Вы имеете право возвращать из функции)


	//Объявите и проинициализируйте массив указателей на функции
	//GetString1,GetString2...
	//Введите номер функции, которую Вы хотите вызвать:
		int n;



	//Вызовите функцию



	//Распечатайте результат


	*/
////////////////////////////////////////////////////////////////////////////
	//Задание 7*.
	//Создайте одномерный массив (размерность вычисляется в процессе
	//выполнения программы), заполните его значениями.
	//Напишите функцию, которая добавляет в массив новое значение только (!) при условии,
	//что такого значения в массиве еще нет. 
	//Подсказка: при этом размер  массива должен увеличиться!
	//Для проверки напишите функцию, которая выводит значения всех элементов на экран
///////////////////////////////////////////////////////////////////////////

	//Задание 8.  
	//Рекурсивные функции.
	//8.1.Написать рекурсивную функцию вычисления суммы первых N натуральных чисел. 
	//8.2.Написать рекурсивную функцию вычисления количества цифр 10-чного натурального числа 
	//8.3.Написать рекурсивную функцию для вывода на экран строки в обратном порядке. 
	//8.4.Написать рекурсивную функцию для вывода на экран строки в прямом (!) порядке.
	


	
	
	

	return 0;
}//main

