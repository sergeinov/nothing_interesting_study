/*************************************************************
	Практическое занятие №1. Встроенные многомерные массивы.
							Динамическое выделение памяти.
							Простейшие алгоритмы сортировки и поиска.
							Сложные указатели.
							Ссылки.
*************************************************************/

#define	  stop __asm nop
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <string.h>
#include <ctime>

int main()
{
	setlocale(LC_ALL, "Rus");
///////////////////////////////////////////////////////////////
//			Встроенные  многомерные массивы                               //
///////////////////////////////////////////////////////////////
	{
		using namespace std;
		//Задание 1.
		//Объявите трехмерный N*M*K массив и сформируйте указанные
		//значения элементов следующим образом:
		//а) проинициализируйте массив при объявлении
		

		int arr1[3][3][3] = {
			{{1,1,1},{1,1,1},{1,1,1}},
			{{2,2,2},{2,2,2},{2,2,2}},
			{{3,3,3},{3,3,3},{3,3,3}}
		};
		
		//б) объявите неинициализированный массив и присвойте значения элементам
		//	с помощью кода
		//					 |--------|		
		//				   / |3  3  3 |		
		//    			 |---------|3 |
			//		   / | 2  2  2 |3 |
		//			  |---------|2 |__|
		//			  | 1  1  1 |2 | /
		//			  | 1  1  1 |__| 
		//			  | 1  1  1 | /
		//			  |_________|
		//Рекомендация: В качестве размерностей массива лучше указать N, M, K,
		//а не  задавать их жестко.  
		//Средствами отладчика проверьте правильность Вашего решения. 
		//Или выведите содержимое массива на печать.
		// Удобно выводить построчно каждый слой  массива и 
		//после каждого слоя пропускать строку для того, чтобы отделить один слой от другого
		std::cout << "Задание 1.б" << std::endl;

		const int N = 3, M = 3, K = 4;

		int arr2[N][M][K];
		int* temp = &arr2[0][0][0];
		// заполнение массива
		for (size_t i = 0; i < N * K * M; i++)
		{
			/*for (size_t j = 0; j < M; j++)
			{
				for (size_t k = 0; k < K; k++)
				{
					arr2[0][j][k] = 1;
					arr2[1][j][k] = 2;
					arr2[2][j][k] = 3;
				}
			}	*/	
			// второй способ
			temp[i] = i / (M * K) + 1;
		}
		
		// вывод массива 
		for (size_t i = 0; i < N; i++)
		{
			for (size_t j = 0; j < M; j++)
			{
				for (size_t k = 0; k < K; k++)
				{
					cout << arr2[i][j][k] << " ";
				}
				std::cout << std::endl;
			}
			std::cout  << std::endl;
		}	

		//в) найдите сумму элементов массива. Подумайте, как это сделать эффективно.

		std::cout << "Задание 1.в"<< std::endl;
		int* p = &arr2[0][0][0];	// вспомогательный адрес с начальным элементом
		int sum = 0;

		for (size_t i = 0; i < sizeof(arr2)/sizeof(int); i++)
		{
			sum += *p;
			p++;
		}
		std::cout << sum << std::endl;
		/*
		// второй вариант
		int (*p)[M][K] = arr2;	
		for (size_t i = 0; i < 3; i++)
		{
			for (int j = 0; j < M; j++) {
				for (int k = 0; k < K; k++) {
					sum += *(*(*(p + i) + j) + k);

				}
			}

		}*/

		//г) проинициализируйте массив при определении:
		//				     |--------|		
		//			       / |3  0  0 |		
		//      		 |---------|0 |
		//    		   / | 2  0  0 |0 |
		//			  |---------|0 |__|
		//			  | 1  0  0 |0 | /
		//			  | 0  0  0 |__| 
		//			  | 0  0  0 | /
		//			  |_________|
		std::cout << "\nЗадание 1.г" << std::endl;
		int arr3[N][M][K] = {
			{1},
			{2},
			{3}
		};
		// вывод массива 
		for (size_t i = 0; i < N; i++)
		{
			for (size_t j = 0; j < M; j++)
			{
				for (size_t k = 0; k < K; k++)
				{
					cout << arr3[i][j][k] << " ";
				}
				std::cout << std::endl;
			}
			std::cout << std::endl;
		}

		//д) Инициализация массивов строковыми литералами:
		//Объявите и проинициализируйте строковыми литералами два массива:
		//двухмерный массив и массив указателей. Поясните разницу в использовании
		//элементов таких массивов.
		std::cout << "Задание 1.д" << std::endl;

		// двумерный массив строковых литералов 
		// мы можем читать и писать в массив 
		// arr4[1][1] = "P";  //ok  "HPV"
		char arr4[2][4] = {					
							{"ABC"},
							{"HTV"}
		};

		// массив указателей на char
		// нельзя писать в память массива указателей
		// будет ошибка времени выполнения
		const char* arr5[] = { "Hello", "World" };  		
		std::cout << *(arr5[1]) << std::endl;	//  адрес начала второго указателя   "W"
		//*arr5[5] = 'H';


	}
/////////////////////////////////////////////////////////////////////
//Задание 2.
//С помощью данной заготовки напишите программу,которая:
//вводит строки с клавиатуры с помощью cin>>...
//в объявленный Вами двухмерный ВСТРОЕННЫЙ массив 10*80 элементов типа char;
//признаком конца ввода является символ * (то есть строка - "*") или
//заполнение всего массива (больше свободных строк нет);

//То есть:
	//a) можно заполнять весь массив полностью (не забудьте подсказать, сколько элементов в массиве)
	//б) можно заполнять массив частично, до тех пор, пока пользователь не ввел строку "*".
	//Например:вводим строки (строки с пробелами не задаются, т.к. пробелы являются разделителями):
	//"Hello"
	//"Ok"
	//"*"
//сортировка строк в алфавитном порядке. 
//Пояснение: крайне не рекомендуется для сортировки сложных объектов физически
//перемещать их в памяти ( в нашем случае перемещать (копировать) строки)
//Намного эффективнее завести массив указателей на соответствующие строки 
//и перемещать только указатели на начало строк (массивов символов).
//Вопрос: При таком способе что будет  отсортировано?

//Подсказка: для лексикографического сравнения строк пользуйтесь
//функцией стандартной библиотеки strcmp(...), заголовочный файл <string.h>.
//int strcmp(char const* _Str1, char const* _Str2);
	{
		std::cout << "\nЗадание 2" << std::endl;
		//Определите необходимые значения как константы
		//STOP_STRING  -  "*"	//признак "прекратить ввод"
		//M  -  80	//максимальный размер одной строки
		//N  -  10	//максимальное количество строк в массиве
		const char N = 10, M = 80, STOP_STRING = '*';


		//Объявите двухмерный массив с именем cBuffer типа char и
		// размерностью N*M
		char cBuffer[N][M] = {};
		int NumberStr = N;

		//Объявите массив (с именем cPointers) указателей на строки
		//размерностью N
		char* cPointers[N] = {nullptr};

		//Цикл ввода строк:
		//а) выведите приглашение для ввода
		std::cout << "Введите строки: " << std::endl;

		for (size_t i = 0; i < N; i++)
		{
			//ввод строки в массив cBuffer:
			std::cin >> cBuffer[i];

			//пока не введена строка STOP_STRING или не заполнен весь массив
			if (cBuffer[i][0] == STOP_STRING)
			{
				NumberStr = i;
				//если введена строка - признак окончания, то выйти из цикла
				break;
			}

			//Присвойте элементу массива cPointers с индексом nIndex
			//указатель на строку с номером nIndex в массиве cBuffer
			cPointers[i] = cBuffer[i];
		}

		//Выдать диагностику о том, что прием строк завершен.
		std::cout << "Ввод завершен!" << std::endl;


	//Теперь сортируем строки:
	//Цикл сортировки строк по методу "всплывающего пузырька" в
	//порядке возрастания кода первого символа

	// вариант без лишней сортировки
		for (int i = 0; i < NumberStr; i++)
		{
			bool flag = false;		// для выключения лишнего перебора чисел (была ли хотя бы одна перестановка)

			// поиск из оставшихся неупорядоченных чисел
			for (int j = 0; j < NumberStr -1; j++)
			{
				if (strcmp(cPointers[j], cPointers[j + 1]) > 0)
				{
					if ((j + 1) == NumberStr) {
						break;
					}
					char* tmp = cPointers[j];	// обмен элементов 
					cPointers[j] = cPointers[j + 1];
					cPointers[j + 1] = tmp;
					flag = true;
				}
			}
			if (!flag)
			{
				break;
			}
		}

		std::cout << "\nВывод отсортированного массива: " << std::endl;
		// вывод массива 
		for (size_t i = 0; i < NumberStr; i++)
		{
			std::cout << cPointers[i] << std::endl;
			/*for (size_t j = 0; j < M; j++)
			{
					std::cout<<*(*(cPointers+i)+j)<<" ";
			}*/
			std::cout << std::endl;
		}

	}
//////////////////////////////////////////////////////////////////////////////

//Задание 3*. Объявление и использование указателей на многомерные
// массивы. Проинициализируйте трехмерный массив
//double dArray[4][3][3] так, как показано на рисунке и напишите фрагмент
//кода, который меняет местами значения элементов четных
//и нечетных слоев:
//	было:			     |--------|
//  				   / |4  4  4 |
//				     |--------| 4 |
//			       / |3  3  3 | 4 |
//    			 |---------|3 |   |
//			   / | 2  2  2 |3 | /
//			  |---------|2 |__|
//			  | 1  1  1 |2 | /
//			  | 1  1  1 |__|
//			  | 1  1  1 | /
//			  |_________|

//	стало:			     |--------|
//  				   / |3  3  3 |
//				     |--------| 3 |
//			       / |4  4  4 | 3 |
//    			 |---------|4 |   |
//			   / | 1  1  1 |4 | /
//			  |---------|1 |__|
//			  | 2  2  2 |1 | /
//			  | 2  2  2 |__|
//			  | 2  2  2 | /
//			  |_________|
/*
for(int i=0; i<...; ...)
{
//Замечание: НЕ НУЖНО МОДИФИЦИРОВАТЬ ВЫРАЖЕНИЯ СПРАВА ОТ ЗНАКА РАВЕНСТВА!!!
... =  dArray[i];
... =  dArray[i+1];
*/
//Подсказки: 
//1) Слева от знака равенства надо определить два  сложных указателя. 
//Так как справа находятся "имена" слоев, т.е. двумерных массивов, то
// остается вспомнить какой указатель является эквивалентным имени двумерного массива.

//2)дальше, воспользовавшись этими указателями, переставляем местами элементы i-того и i+1-ого слоев
	{
		std::cout << "\nЗадание 3" << std::endl;
		const int N = 4, M = 3, K = 3;
		double dArray[N][M][K] = {
			{{1,1,1},{1,1,1},{1,1,1}},
			{{2,2,2},{2,2,2},{2,2,2}},
			{{3,3,3},{3,3,3},{3,3,3}},
			{{4,4,4},{4,4,4},{4,4,4}}
		};
		double(*pdArray)[K] = dArray[0];	// эквивалентный указатель  для имени трехмерного массива 

		//double* ptrPdArray = &pdArray[0][1];  // указатель на  массив указателей

		// вывод массива
		for (size_t i = 0; i < N; i++)
		{
			for (size_t j = 0; j < M; j++)
			{
				for (size_t k = 0; k < K; k++)
				{
					std::cout << dArray[i][j][k] << " ";
				}
				std::cout  << std::endl;
			}
			std::cout << std::endl;
		}

		// обмен нечетных слоев
		std::cout << "\nОбмен..." << std::endl;
		for (size_t i = 0; i < N; i+=2)
		{
			double(*pdArray1)[K] = dArray[i];
			double(*pdArray2)[K] = dArray[i + 1];
			for (size_t j = 0; j < M; j++)
			{
				for (size_t k = 0; k < K; k++)
				{
					double temp = pdArray1[j][k];
					pdArray1[j][k] = pdArray2[j][k];
					pdArray2[j][k] = temp;
				}
			}
		}

		// вывод массива
		for (size_t i = 0; i < N; i++)
		{
			for (size_t j = 0; j < M; j++)
			{
				for (size_t k = 0; k < K; k++)
				{
					std::cout << dArray[i][j][k] << " ";
				}
				std::cout << std::endl;
			}
			std::cout << std::endl;
		}

	}


///////////////////////////////////////////////////////////////////////////

//Задание 4
//а) Объявите двухмерный ВСТРОЕННЫЙ массив элементов типа char.
//Сформируйте значения элементов массива с помощью генератора случайных
//чисел таким образом, чтобы в массиве были только символы '_' и '*'
	
	//Подсказка 1: для генерации случайных чисел используйте функцию
	//стандартной библиотеки - rand() (<cstdlib>)
	//Можно с помощью генератора случайных чисел  и оператора % получать значения 0 и 1,
	// а в массив помещать соответственно '_' и '*'.

	
	//Подсказка 2: На самом деле те значения, которые создаются генератором случайных
	//чисел являются «псевдослучайными», то есть при двух последовательных запусках
	//приложения Вы получаете две одинаковые последовательности значений.
	//Для того чтобы генерируемые "случайные" значения были разными при каждом
	//запуске приложения используйте функции стандартной библиотеки srand() (<cstdlib>)
	//и time() (<ctime>).
	//Функция srand() осуществляет «привязку» начала генерации к указанному в качестве параметра значению.
	//Функция time() задает эту точку отсчета, считывая текущее время
	//srand( time( 0 ) );
	
	//Замечание: в программе запускать функцию srand()  достаточно один раз 
    

//В каждой строке "сдвиньте звездочки" в начало строки, например:
//было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
//стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
//и распечатайте массив по строкам - "постройте распределение"
	{
		std::cout << "\nЗадание 4" << std::endl;
		std::cout << "\nМассив..." << std::endl;
		const int N = 8, M = 5;
		srand(time(NULL));
		char arrRandom[N][M];

		// заполнение массива случайными числами и замена их на символы  '*'  '_'
		for (int i = 0; i < N; i++)
		{
			for (size_t j = 0; j < M; j++)
			{
				arrRandom[i][j] = (rand() % 2) ? '*' : '_';
			}

		}

		// вывод массива 
		for (size_t i = 0; i < N; i++)
		{
			for (size_t j = 0; j < M; j++)
			{
				std::cout << arrRandom[i][j] << " ";
			}
			std::cout << std::endl;
		}

		//В каждой строке "сдвиньте звездочки" в начало строки, например:
		// проходим по всему массиву пузырьковой сортировкой (в порядке возрастания)
		std::cout << "\nСортировка звездочки в начало строки..." << std::endl;
		int  index = 0;
		for (int i = 0; i < N; i++)
		{
			bool flag = false;		// для выключения лишнего перебора чисел (была ли хотя бы одна перестановка)
			

			for (int j = 0; j < M; j++)
			{
				for (size_t k = 0; k < N; k++)
				{
					// проверка на последний элемент массива
					if (j == N - 1 && k == M - 1)
					{
						continue;
					}
					
					// сравниваем элементы и меняем местами
					if (arrRandom[j][k] == '*')
					{
						index++;

							arrRandom[j][index] = '*';


						flag = true;
					}
					/*arrRandom[j][k] = ;
					arrRandom[j][index] = arrRandom[j][k + 1];
					arrRandom[j][k + 1] = temp;*/
				}
				
			}
			index = 0;
			if (!flag) {
				break;
			}
		}

		// вывод  отсортированного массива 
		for (size_t i = 0; i < N; i++)
		{
			for (size_t j = 0; j < M; j++)
			{
				std::cout << arrRandom[i][j] << " ";
			}
			std::cout << std::endl;
		}


		// б) Модифицируйте предыдущее задание следующим способом:
		//После заполнения массива с помощью генератора случайных чисел
		//"сдвиньте" звездочки по столбцам вниз и распечатайте полученное
		//"распределение"

		std::cout << "\nСортировка звездочки по столбцам вниз..." << std::endl;
		/*for (int i = 0; i < N; i++)
		{
			bool flag = false;		// для выключения лишнего перебора чисел (была ли хотя бы одна перестановка)

			for (int j = 0; j < M - 1; j++)
			{
				for (size_t k = 0; k < M; k++)
				{
					// проверка на последний элемент массива
					if (j == N - 1 && k == M - 1)
					{
						continue;
					}
					// сравниваем элементы и меняем местами
					if (arrRandom[j][k] == '*' && arrRandom[j + 1][k] == '_')
					{

						//   ?
						char temp = arrRandom[j][k];
						arrRandom[j][k] = arrRandom[j+1][k];
						arrRandom[j+1][k] = temp;

						flag = true;
					}
				}
			}
			if (!flag) {
				break;
			}
		}


		// вывод  отсортированного массива 
		for (size_t i = 0; i < N; i++)
		{
			for (size_t j = 0; j < M; j++)
			{
				std::cout << arrRandom[i][j] << " ";
			}
			std::cout << std::endl;
		}*/
	}
///////////////////////////////////////////////////////////////
//			Динамическое выделение памяти                    //
///////////////////////////////////////////////////////////////
//Задание 5.
	{
		////Задание 5а.Создайте ДИНАМИЧЕСКИЙ двухмерный массив с размерностями,
		//вычисляемыми в процессе выполнения программы - N*M.
		//Задайте значения элементов помощью генератора случайных чисел.
		std::cout << "\nЗадание 5.a" << std::endl;
		int N = 5;
		int M = 5;

		int** pArrNumbers = new int*[N];		// выделяется память массива указателей на строки

		// // выделяем память на строки
		for (size_t i = 0; i < N; i++)
		{
			pArrNumbers[i] = new int[M];
		}

		// заполнение массива 
		for (size_t i = 0; i < N; i++)
		{
			for (size_t j = 0; j < M; j++)
			{
					//  рандомные числа от 1 -10
					pArrNumbers[i][j] = (rand() % 10 + 1);
					std::cout << pArrNumbers[i][j] << " ";
			}
			std::cout << std::endl;
		}

		//Задание 5б. В сформированном массиве отсортируйте каждую строку по
		//убыванию значений. Используйте сортировку "выбором"
		std::cout << "\nЗадание 5.б" << std::endl;
		std::cout << "\nСортировка..." << std::endl;

		int temp = 0;
		 //проходим по всему массиву
		for (int i = 0; i < N; i++)	// цикл по строкам
		{

			// поиск наибольшего из оставшихся неупорядоченных чисел
			for (int j = i + 1; j < M; j++)		// цикл шага
			{
				int indexMax = j;  // здесь индекс  наибольшего элемента

				for (size_t k = j + 1; k < M; k++)	// цикл выбора наибольшегоэлемента
				{
					if (pArrNumbers[j][k] > pArrNumbers[j][indexMax])
					{
						int indexMax = k;	
					}
				}
				// обмен местами значения текущего и наибольшего элементов
				temp = pArrNumbers[j][indexMax];
				pArrNumbers[j][indexMax] = pArrNumbers[i][j];
				pArrNumbers[i][j] = temp;
				//std::cout << pArrNumbers[i][j] << " ";			
			}

		}
		
		// вывод массива
		for (int i = 0; i < N; i++)
		{
			for (size_t j = 0; j < M; j++)
			{
				std::cout << pArrNumbers[i][j] << " ";
			}
			std::cout << std::endl;
		}
		std::cout << std::endl;

		
		

		//Задание 5в. Объявите одномерный массив размерностью N.
		//Сформируйте значение i-ого элемента одномерного массива  
		//равным среднему значению элементов i-ой строки
		//двухмерного массива
		
		std::cout << "\nЗадание 5.в" << std::endl;

		double* pArr2 = new double[N];
		double sum = 0;

		for (size_t i = 0; i < N; i++)
		{
			for (size_t j = 0; j < M; j++)
			{
				// считаем сумму строки
				sum += pArrNumbers[i][j];
			}
			sum /= M;
			pArr2[i] = sum;
		}

		std::cout << "\nСреднее значение элементов i-ой строки двухмерного массива" << std::endl;
			//двухмерного массива" << std::endl;
		// вывод массива
		for (int i = 0; i < N; i++)
		{
			std::cout << pArr2[i] << " ";
		}

		//Подсказка - не забудьте освободить память!
		std::cout << "\n\nОсвобождаем память двухмерного..." << std::endl;
		for (size_t i = 0; i < N; i++)
		{
			delete[]  pArrNumbers[i];
		}
		delete[] pArrNumbers;
		pArrNumbers = 0;

		std::cout << "Освобождаем память одномерного..." << std::endl;
		delete[] pArr2;
		pArr2 = 0;
		
	}

/////////////////////////////////////////////////////////////////////////////
	//Задание 6. 
	{
		//Реализуйте задание №2, используя не встроенные, а ДИНАМИЧЕСКИЕ массивы (массив?).
		// Важно! 
		//Так как строки могут быть разной длины, /эффективным решением было бы 
		//отводить под каждую строку ровно столько байтов, сколько требуется для ее хранения.
		//
		//Для того, чтобы определить длину введенной строки можно воспользоваться 
		//функцией strlen 
		//size_t strlen(char const* _Str);
		std::cout << "\nЗадание 6" << std::endl;

		int N = 5;

		char** ppStrArr = new char* [N];	// впомогательный указатель для обращения привычным способом [i][j]

		/*for (size_t i = 0; i < N; i++)
		{
			ppStrArr[i] = new char[];	// направляем каждый  i  указатель на начало соответствующей  i строки
		}*/

		// Для ввода строки нужно использовать буфер "достаточного" размера.
		

		//Цикл ввода строк:
		/*for (int i = 0; i < 2; i++)
		{
			std::cout << "Введите строку: " << std::endl;
			char strBuffer[1024] = {};
			//ввод строки в массив strBuffer:
			std::cin >> strBuffer;
			M += strlen(strBuffer); // вычислим длину нашей строки
			N += 1;					// увеличили количество строк

			// выделили новый блок памяти
			char* tmp = new char[N * M];
			// переписали в новый блок старое содержимое
			for (size_t i = 0; i < (N - 1) * M; i++)
			{
				tmp[i] = pStrArr[i];
			}

			// освободили старый массив
			delete[] pStrArr;
			// перенаправили указатель на новый массив
			pStrArr = tmp;
			delete[] ppStrArr;  // освободили память занятую вспомогательным массивом указателей

			ppStrArr = new char* [N];  // выделили блок больше чем предыдущий
			// сформировали новые адреса
			for (size_t i = 0; i < N; i++)
			{
				ppStrArr[i] = new char[M];	// направляем каждый  i  указатель на начало соответствующей  i строки
			}

		}

		//char* pStrArr = new char[N * M];
		//char** ppStrArr = new char* [N];	// впомогательный указатель для обращения привычным способом [i][j]

		

		//При этом значение количества строк сформируйте с помощью потока ввода
		//int nStringNumber;	

		
	
		
		// вывод массива
		for (int i = 0; i < N; i++) 
		{
			for (size_t j = 0; j < M; j++)
			{
				std::cout << ppStrArr[i][j];
			}
			std::cout << std::endl;
		}*/
		
		// Для ввода строки нужно использовать буфер "достаточного" размера. 
		// В качестве такого буфера обычно используется встроенный массив.
		// Для того, чтобы введенную строку  скопировать из буфера в массив  строк,
		// можно воспользоваться функцией strcpy
		//char* strcpy_s(	char* _Dest,  char const* _Source);
		//  или
		//errno_t strcpy_s(char* _Dest, size_t  _SizeInBytes, char const* _Source); 
		//где _SizeInBytes - размер "приемного" буфера.
		//Замечание: 
		//скорее всего, при компиляции Вы получите следующую ошибку:
		//Severity	Code	Description	Project	File	Line	Suppression State
		//	Error	C4996	'strcpy': This function or variable may be unsafe.
		//Consider using strcpy_s instead.To disable deprecation, use _CRT_SECURE_NO_WARNINGS.

		//Это происходит потому, что функция strcpy считается небезопасной.

		//Для того, чтобы пользоваться функцией strcpy, а не strcpy_s, можно
		//  - либо объявить макрос #define _CRT_SECURE_NO_WARNINGS   (обязательно ДО всех #include !!!!!)
		//- либо установить режим без доп. проверки на безопасность Properties->C/C++ ->General->SDL checs -> No


		//Цикл сортировки строк по методу "всплывающего пузырька" в
		//порядке возрастания кода первого символа





		//Освобождение занятой памяти:

		/*for (int i = 0; i < N; i++) 
		{
			delete[]  ppStrArr[i];
		}
		delete[] ppStrArr;
		ppStrArr = 0;*/

	}
	
	return 0; 
}